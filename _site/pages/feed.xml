<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>陈方勇的网络笔记</title>
    <description>陈方勇的网络笔记
</description>
    <link>http://0.0.0.0:4000/</link>
    <atom:link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 12 Sep 2023 22:00:34 +0800</pubDate>
    <lastBuildDate>Tue, 12 Sep 2023 22:00:34 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>leetcode 51-60</title>
        <description>&lt;h3 id=&quot;51n皇后&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/description/&quot;&gt;51.N皇后&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;将n个皇后放在nxn的棋盘上，使皇后之间不能相互攻击，求所有可行解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def solveNQueens(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: List[List[str]]
        &quot;&quot;&quot;
        
        def ok(x, y, tab, n):
            for i in range(x):
                if tab[i][y] == 'Q':
                    return False
            i, j = x-1, y-1
            while i &amp;gt;= 0 and j &amp;gt;= 0:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            i, j = x-1, y+1
            while i &amp;gt;= 0 and j &amp;lt; n:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True
        
        def dfs(x, tab, ans, n):
            if x == n:
                t = []
                for i in tab:
                    t.append(''.join(i))
                ans.append(t)
                return
            for y in range(n):
                if ok(x, y, tab, n):
                    tab[x][y] = 'Q'
                    dfs(x+1, tab, ans, n)
                    tab[x][y] = '.'
        
        ans = []
        tab = [['.' for i in range(n)] for j in range(n)]
        dfs(0, tab, ans, n)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;52n皇后ii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens-ii/description/&quot;&gt;52.N皇后II&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;将n个皇后放在nxn的棋盘上，使皇后之间不能相互攻击，求所有解的数量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def totalNQueens(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        
        def ok(x, y, tab, n):
            for i in range(x):
                if tab[i][y] == 'Q':
                    return False
            i, j = x-1, y-1
            while i &amp;gt;= 0 and j &amp;gt;= 0:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            i, j = x-1, y+1
            while i &amp;gt;= 0 and j &amp;lt; n:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True
        
        def dfs(x, tab, n, ans):
            if x == n:
                ans.append(1)
                return
            for y in range(n):
                if ok(x, y, tab, n):
                    tab[x][y] = 'Q'
                    dfs(x+1, tab, n, ans)
                    tab[x][y] = '.'
        
        ans = []
        tab = [['.' for i in range(n)] for j in range(n)]
        dfs(0, tab, n, ans)
        return len(ans)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;53最大子序和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/description/&quot;&gt;53.最大子序和&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个非空的整数数组，找出一个具有最大和的连续非空子数组，返回其最大和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def maxSubArray(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        dp = [nums[0]]
        for i in range(1, len(nums)):
            dp.append(max(nums[i], nums[i]+dp[i-1]))
        return max(dp)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;54螺旋矩阵&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/spiral-matrix/description/&quot;&gt;54.螺旋矩阵&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个包含mxn个元素的矩阵，按顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def spiralOrder(self, matrix):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :rtype: List[int]
        &quot;&quot;&quot;
        ans = []
        if not matrix: return []
        m, n = len(matrix), len(matrix[0])
        tab = [[0 for i in range(n)] for j in range(m)]
        x, y = 0, -1
        while len(ans) &amp;lt; m*n:
            while y+1 &amp;lt; n and tab[x][y+1] == 0:
                y += 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
            while x+1 &amp;lt; m and tab[x+1][y] == 0:
                x += 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
            while y-1 &amp;gt;= 0 and tab[x][y-1] == 0:
                y -= 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
            while x-1 &amp;gt;= 0 and tab[x-1][y] == 0:
                x -= 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;55跳跃游戏&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game/description/&quot;&gt;55.跳跃游戏&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个非负整数数组，最初位于第一个位置，数组中每个元素代表在该位置可以跳跃的最大长度，判断是否能够到达最后一个位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def canJump(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: bool
        &quot;&quot;&quot;
        mx = 0
        for i, x in enumerate(nums):
            if i &amp;gt; mx:
                return False
            mx = max(mx, i+nums[i])
        return True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;56合并区间&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-intervals/description/&quot;&gt;56.合并区间&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给出一个区间的集合，合并所有重叠的区间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for an interval.
# class Interval:
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution:
    def merge(self, intervals):
        &quot;&quot;&quot;
        :type intervals: List[Interval]
        :rtype: List[Interval]
        &quot;&quot;&quot;
        intervals.sort(key = lambda x: x.start)
        ans = []
        t = None
        for i in intervals:
            if t is None:
                t = i
            else:
                if t.end &amp;gt;= i.start:
                    t.end = max(t.end, i.end)
                else:
                    ans.append(t)
                    t = i
        if t:
            ans.append(t)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;57插入区间&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/insert-interval/description/&quot;&gt;57.插入区间&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给出一个元重复的，按照区间起始端点排序的区间列表，在列表中插入一个新的区间，要确保插完后新的列表中的区间仍然有序且不重复（如有必果，可以合并区间）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for an interval.
# class Interval:
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution:
    def insert(self, intervals, newInterval):
        &quot;&quot;&quot;
        :type intervals: List[Interval]
        :type newInterval: Interval
        :rtype: List[Interval]
        &quot;&quot;&quot;
        intervals.append(newInterval)
        intervals.sort(key = lambda x: x.start)
        ans = []
        t = None
        for i in intervals:
            if t is None:
                t = i
            else:
                if t.end &amp;gt;= i.start:
                    t.end = max(t.end, i.end)
                else:
                    ans.append(t)
                    t = i
        if t: ans.append(t)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;58最后一个单词的长度&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/length-of-last-word/description/&quot;&gt;58.最后一个单词的长度&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个仅包含大小写字母和空格的字符串，返回其最后一个单词的长度。如不存在最后一个单词，返回0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def lengthOfLastWord(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        w = s.split()
        return len(w[-1]) if w else 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;59螺旋矩阵ii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/spiral-matrix-ii/description/&quot;&gt;59.螺旋矩阵II&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个正整数n，生成一个包含1到n*n所有元素，且元素按顺时针螺旋排列的方形矩阵。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def generateMatrix(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        ans = [[0 for i in range(n)] for j in range(n)]
        x, y = 0, -1
        cnt = 0
        while cnt &amp;lt; n*n:
            while y+1 &amp;lt; n and ans[x][y+1] == 0:
                y += 1
                cnt += 1
                ans[x][y] = cnt
            while x+1 &amp;lt; n and ans[x+1][y] == 0:
                x += 1
                cnt += 1
                ans[x][y] = cnt
            while y-1 &amp;gt;= 0 and ans[x][y-1] == 0:
                y -= 1
                cnt += 1
                ans[x][y] = cnt
            while x-1 &amp;gt;= 0 and ans[x-1][y] == 0:
                x -= 1
                cnt += 1
                ans[x][y] = cnt
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;60第k个排列&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/permutation-sequence/description/&quot;&gt;60.第k个排列&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给出集合[1,2,3,…,n]，其所有元素共有n!种排列，求第k小的排列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def getPermutation(self, n, k):
        &quot;&quot;&quot;
        :type n: int
        :type k: int
        :rtype: str
        &quot;&quot;&quot;
        z = [i for i in range(1, n+1)]
        p = 1
        for i in range(1,n):
            p *= i
        k -= 1
        ans = ''
        for i in range(n):
            x, y = divmod(k, p)
            ans += str(z.pop(x))
            k = y
            if n-1 &amp;gt; i:
                p //= n-1-i
        return ans
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 11 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/08/11/leetcode-51-60.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/08/11/leetcode-51-60.html</guid>
        
        
        <category>LeetCode</category>
        
      </item>
    
      <item>
        <title>leetcode 41-50</title>
        <description>&lt;h3 id=&quot;41缺失的第一个正整数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive/description/&quot;&gt;41.缺失的第一个正整数&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个未排序的整数数组，找出其中没有出现的最小正整数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def firstMissingPositive(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        s = set(nums)
        i = 1
        while i in s:
            i += 1
        return i
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;42接雨水&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/description/&quot;&gt;42.接雨水&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少水。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def trap(self, height):
        &quot;&quot;&quot;
        :type height: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(height)
        height.insert(0, 0)
        height.append(0)
        L = [0] * (n+5)
        R = [0] * (n+5)
        for i in range(1, n+1):
            L[i] = max(L[i-1], height[i])
        for i in range(n, 0, -1):
            R[i] = max(R[i+1], height[i])
        ans = 0
        for i in range(1, n+1):
            ans += max(0, min(L[i-1], R[i+1]) - height[i])
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;43字符串相乘&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/multiply-strings/description/&quot;&gt;43.字符串相乘&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定两个以字符串形式表示的非负整数num1和num2，求其乘积，也用字符串表示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def multiply(self, num1, num2):
        &quot;&quot;&quot;
        :type num1: str
        :type num2: str
        :rtype: str
        &quot;&quot;&quot;
        return str(int(num1) * int(num2))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;44-通配符匹配&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/wildcard-matching/description/&quot;&gt;44. 通配符匹配&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个字符串s和一个字符模式p，实现一个支持'?'和'*'的通配匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution(object):
    def isMatch(self, s, p):
        ls, lp = len(s), len(p)
        dp = [[False for c in range(ls+1)] for r in range(lp+1)]
        dp[0][0] = True
        for i in range(1, lp+1):
            dp[i][0] = p[i-1] == '*' and dp[i-1][0]
        for i in range(1, lp+1):
            for j in range(1, ls+1):
                if p[i-1] == s[j-1] or p[i-1] == '?':
                    dp[i][j] = dp[i-1][j-1]
                elif p[i-1] == '*':
                    dp[i][j] = dp[i-1][j] or dp[i][j-1]
        return dp[lp][ls]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;45跳跃游戏&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jump-game-ii/description/&quot;&gt;45.跳跃游戏&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个非负整数数组，最初位于数组的第一个位置，数组中每个元素代表在该位置可以跳跃的最大长度，用最少的步数到达最后一个位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def jump(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        C, R = 0, 0
        ans = 0
        for i, j in enumerate(nums):
            if i &amp;gt; C:
                ans += 1
                C = R
            R = max(R, i+j)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;46全排列&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/permutations/description/&quot;&gt;46.全排列&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个没有重复数字的序列，返回其所有可能的全排列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def permute(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        
        def dfs(idx, tmp, nums, ans):
            if idx == len(nums):
                ans.append(tmp[::])
                return
            for i in range(idx, len(nums)):
                nums[idx], nums[i] = nums[i], nums[idx]
                dfs(idx+1, tmp+[nums[idx]], nums, ans)
                nums[idx], nums[i] = nums[i], nums[idx]
            
        ans = []
        dfs(0, [], nums, ans)
        return sorted(ans)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;47全排列ii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/permutations-ii/description/&quot;&gt;47.全排列II&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个可包含重复数字的序列，返回所有不重复的全排列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def permuteUnique(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        def dfs(idx, tmp, nums, ans):
            if idx == len(nums):
                ans.add(tuple(tmp))
                return
            for i in range(idx, len(nums)):
                nums[idx], nums[i] = nums[i], nums[idx]
                dfs(idx+1, tmp+[nums[idx]], nums, ans)
                nums[idx], nums[i] = nums[i], nums[idx]
        
        ans = set()
        dfs(0, [], nums, ans)
        return sorted(list(ans))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;48旋转图像&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-image/description/&quot;&gt;48.旋转图像&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个nxn的二维矩阵表示一个图像，将图像顺时针旋转90度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def rotate(self, matrix):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        n = len(matrix)
        for i in range(n):
            for j in range(i+1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for i in range(n):
            L, R = 0, n-1
            while L &amp;lt; R:
                matrix[i][L], matrix[i][R] = matrix[i][R], matrix[i][L]
                L += 1
                R -= 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;49字母异位词分组&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/group-anagrams/description/&quot;&gt;49.字母异位词分组&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def groupAnagrams(self, strs):
        &quot;&quot;&quot;
        :type strs: List[str]
        :rtype: List[List[str]]
        &quot;&quot;&quot;
        mp = {}
        for i in strs:
            k = ''.join(sorted(i))
            if k in mp:
                mp[k].append(i)
            else:
                mp[k] = [i]
        ans = []
        for v in mp.values():
            ans.append(v)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;50求幂&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/description/&quot;&gt;50.求幂&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;实现pow(x,n)，即计算x的n次幂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def myPow(self, x, n):
        &quot;&quot;&quot;
        :type x: float
        :type n: int
        :rtype: float
        &quot;&quot;&quot;
        return pow(x, n)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 10 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/08/10/leetcode-41-50.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/08/10/leetcode-41-50.html</guid>
        
        
        <category>LeetCode</category>
        
      </item>
    
      <item>
        <title>leetcode 31-40</title>
        <description>&lt;h3 id=&quot;31下一个排列&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/description/&quot;&gt;31.下一个排列&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给出一组由正整数构成的序列，要求重排得到字典序中下一个更大的排列，如不存在则排成最小排列，要求原地修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:        
    def nextPermutation(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        
        def reverse(nums, L, R):
            while L &amp;lt; R:
                nums[L], nums[R] = nums[R], nums[L]
                L += 1
                R -= 1
        
        x = len(nums)-2
        while x &amp;gt;= 0 and nums[x] &amp;gt;= nums[x+1]:
            x -= 1
        if x &amp;lt; 0:
            reverse(nums, 0, len(nums)-1)
        else:
            y = len(nums)-1
            while nums[y] &amp;lt;= nums[x]:
                y -= 1
            nums[x], nums[y] = nums[y], nums[x]
            reverse(nums, x+1, len(nums)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;32最长有效括号&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-valid-parentheses/description/&quot;&gt;32.最长有效括号&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个只包含'('和')'的字符串，找出最长的包含有效括号的子串的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def longestValidParentheses(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        stk = []
        dp = [0] * (len(s)+1)
        for i, j in enumerate(s):
            if j == '(':
                stk.append(i)
            else:
                if stk:
                    t = stk.pop()
                    dp[i] = i-t+1
                    if t: dp[i] += dp[t-1]
        return max(dp)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;33搜索旋转数组&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/&quot;&gt;33.搜索旋转数组&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转，现要在数组中搜索一个给定的目标值，如果存在则返回索引，不存在返回-1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def search(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        
        def find1(L, R, nums, target):
            if L &amp;gt; R: return -1
            if nums[L] &amp;lt;= nums[R]:
                return find2(L, R, nums, target)
            M = L + (R-L) // 2
            if nums[L] &amp;lt;= nums[M]:
                if nums[L] &amp;lt;= target &amp;lt;= nums[M]:
                    return find2(L, M, nums, target)
                return find1(M+1, R, nums, target)
            else:
                if nums[M] &amp;lt;= target &amp;lt;= nums[R]:
                    return find2(M, R, nums, target)
                return find1(L, M-1, nums, target)

        def find2(L, R, nums, target):
            lo, hi = L, R
            while lo &amp;lt;= hi:
                mid = lo + (hi-lo) // 2
                if nums[mid] &amp;lt; target:
                    lo = mid+1
                elif nums[mid] &amp;gt; target:
                    hi = mid-1
                else:
                    return mid
            return -1

        return find1(0, len(nums)-1, nums, target)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;34搜索范围&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-for-a-range/description/&quot;&gt;34.搜索范围&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个按照升序排列的整数数组和一个目标值，找出给定目标值在数组中的开始位置和结束位置，如不存在，则返回[-1,-1]。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def searchRange(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        
        def find1(nums, target):
            if not nums: return -1
            lo, hi = 0, len(nums)-1
            while lo &amp;lt; hi:
                mid = lo + (hi-lo) // 2
                if nums[mid] &amp;lt; target:
                    lo = mid+1
                elif nums[mid] &amp;gt; target:
                    hi = mid-1
                else:
                    hi = mid
            if lo &amp;lt; len(nums) and nums[lo] == target:
                return lo
            return -1

        def find2(nums, target):
            if not nums: return -1
            lo, hi = 0, len(nums)-1
            while lo &amp;lt; hi:
                mid = lo + (hi-lo+1) // 2
                if nums[mid] &amp;lt; target:
                    lo = mid+1
                elif nums[mid] &amp;gt; target:
                    hi = mid-1
                else:
                    lo = mid
            if lo &amp;lt; len(nums) and nums[lo] == target:
                return lo
            return -1
    
        L = find1(nums, target)
        R = find2(nums, target)
        return [L, R]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;35搜索插入位置&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-insert-position/description/&quot;&gt;35.搜索插入位置&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果不存在，则返回它将会被按顺序插入的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def searchInsert(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        if not nums: return 0
        lo, hi = 0, len(nums)-1
        while lo &amp;lt; hi:
            mid = lo + (hi - lo) // 2
            if nums[mid] &amp;lt; target:
                lo = mid+1
            else:
                hi = mid
        if lo &amp;lt; len(nums) and nums[lo] &amp;gt;= target:
            return lo
        return lo+1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;36有效的数独&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-sudoku/description/&quot;&gt;36.有效的数独&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;判断一个9x9的数独是否有效，注意给定的数独序列只包含数字1-9和字符'.'，一个有效的数独不一定是可解的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def isValidSudoku(self, board):
        &quot;&quot;&quot;
        :type board: List[List[str]]
        :rtype: bool
        &quot;&quot;&quot;
        def ok(T):
            s = set()
            for i in T:
                if i == '.': continue
                if i in s: return False
                s.add(i)
            return True
        
        for i in range(9):
            t = []
            for j in range(9):
                t.append(board[i][j])
            if not ok(t):
                return False

        for j in range(9):
            t = []
            for i in range(9):
                t.append(board[i][j])
            if not ok(t):
                return False
            
        for i in range(0,9,3):
            for j in range(0,9,3):
                t = []
                for x in range(3):
                    for y in range(3):
                        t.append(board[i+x][j+y])
                if not ok(t):
                    return False
        return True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;37解数独&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sudoku-solver/description/&quot;&gt;37.解数独&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个只包含数字1-9和字符'.'的数独序列，其中'.'代表未确定的数字，解出该数独。输入保证有唯一解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def solveSudoku(self, board):
        &quot;&quot;&quot;
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        
        def ok(T):
            s = set()
            for i in T:
                if i == '.': continue
                if i in s: return False
                s.add(i)
            return True
        
        def checkH(x):
            t = []
            for i in range(9):
                t.append(board[x][i])
            return ok(t)
        
        def checkV(y):
            t = []
            for i in range(9):
                t.append(board[i][y])
            return ok(t)
        
        def checkB(x, y):
            t = []
            for i in range(3):
                for j in range(3):
                    t.append(board[x+i][y+j])
            return ok(t)
        
        def check(x, y):
            return checkH(x) and checkV(y) and checkB(x//3*3, y//3*3)

        def dfs(n):
            if n == 81: return True
            x, y = n//9, n%9
            if board[x][y] != '.':
                return dfs(n+1)
            for i in range(1,10):
                board[x][y] = str(i)
                if check(x, y):
                    if dfs(n+1):
                        return True
            board[x][y] = '.'
            return False
        
        dfs(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;38报数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/count-and-say/description/&quot;&gt;38.报数&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;报数序列是指一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。给定一个正整数n，输出报数序列的第n项。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def countAndSay(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: str
        &quot;&quot;&quot;
        ans = '1'
        for i in range(1, n):
            tmp = ''
            idx = 0
            while idx &amp;lt; len(ans):
                tag = ans[idx]
                cnt = 0
                while idx &amp;lt; len(ans) and ans[idx] == tag:
                    idx += 1
                    cnt += 1
                tmp += str(cnt) + tag
            ans = tmp
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;39组合求和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum/description/&quot;&gt;39.组合求和&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合，注意candidates中的数字可以无限制重复被选取，保证candidates中的数以及target都是正整数。输出结果要求不能包含重复的组合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def combinationSum(self, candidates, target):
        &quot;&quot;&quot;
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        
        def dfs(idx, cur, tmp, ans, candidates, target):
            if cur &amp;gt; target: return
            if cur == target:
                ans.append(tmp.copy())
                return
            if idx == len(candidates):
                return
            dfs(idx+1, cur, tmp+[candidates[idx]], ans, candidates, target)
            dfs(idx, cur+candidates[idx], tmp, ans, candidates, target)
        
        ans = []
        dfs(0, 0, [], ans, candidates, target)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;40组合总和ii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-ii/description/&quot;&gt;40.组合总和II&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合，注意candidates中的数字在每个组合中最多只能使用一次，保证candidates中的数以及target都是正整数，要求解集不能包含重复的组合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def combinationSum2(self, candidates, target):
        &quot;&quot;&quot;
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        
        def dfs(idx, cur, tmp, ans, candidates, target):
            if cur &amp;gt; target: return
            if cur == target:
                ans.add(tuple(tmp))
                return
            if idx == len(candidates):
                return
            dfs(idx+1, cur, tmp, ans, candidates, target)
            dfs(idx+1, cur+candidates[idx], tmp+[candidates[idx]], ans, candidates, target)

        ans = set()
        candidates.sort()
        dfs(0, 0, [], ans, candidates, target)
        return sorted(list(ans))
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 02 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/07/02/leetcode-31-40.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/07/02/leetcode-31-40.html</guid>
        
        
        <category>LeetCode</category>
        
      </item>
    
      <item>
        <title>leetcode 21-30</title>
        <description>&lt;h3 id=&quot;21合并两个有序链表&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists/description/&quot;&gt;21.合并两个有序链表&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        ans = ListNode(0)
        tmp = ans
        while l1 and l2:
            if l1.val &amp;lt;= l2.val:
                tmp.next = l1
                tmp = l1
                l1 = l1.next
            else:
                tmp.next = l2
                tmp = l2
                l2 = l2.next
        if l1: tmp.next = l1
        if l2: tmp.next = l2
        return ans.next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;22括号生成&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses/description/&quot;&gt;22.括号生成&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给出n代表生成括号的对数，要求生成所有可能并且有效的括号组合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def generateParenthesis(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: List[str]
        &quot;&quot;&quot;

        def dfs(L, R, s, ans):
            if L &amp;lt; 0 or R &amp;lt; 0 or L &amp;gt; R:
                return
            if L == 0 and R == 0:
                ans.append(s)
                return
            dfs(L-1, R, s+'(', ans)
            dfs(L, R-1, s+')', ans)

        ans = []
        dfs(n, n, '', ans)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;23合并k个排序链表&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-k-sorted-lists/description/&quot;&gt;23.合并K个排序链表&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;合并K个排序链表，返回合并后的排序链表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists):
        &quot;&quot;&quot;
        :type lists: List[ListNode]
        :rtype: ListNode
        &quot;&quot;&quot;

        def merge(self, A, B):
            X = ListNode(0)
            t = X
            while A and B:
                if A.val &amp;lt;= B.val:
                    t.next = A
                    t = A
                    A = A.next
                else:
                    t.next = B
                    t = B
                    B = B.next
            if A: t.next = A
            if B: t.next = B
            return X.next

        ans = []
        if not lists: return ans
        while len(lists) &amp;gt; 1:
            for i in range(0, len(lists), 2):
                j = i+1
                if j &amp;lt; len(lists):
                    t = merge(lists[i], lists[j])
                    ans.append(t)
                else:
                    ans.append(lists[i])
            lists = ans
            ans = []
        return lists[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;24两两交换链表中的节点&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/&quot;&gt;24.两两交换链表中的节点&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        ans = ListNode(0)
        tmp = ans
        stk = []
        while head:
            stk.append(head)
            head = head.next
            if len(stk) == 2:
                for j in range(2):
                    t = stk.pop()
                    tmp.next = t
                    tmp = t
        while stk:
            t = stk.pop()
            tmp.next = t
            tmp = t
        tmp.next = None
        return ans.next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;25k个一组翻转链表&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/&quot;&gt;25.K个一组翻转链表&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给出一个链表，每K个节点一组进行翻转，并返回翻转后的链表。K为正整数，它的值不超过链表长度。如果节点数不是K的倍数，那么最后整余节点保持原来的顺序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        ans = ListNode(0)
        tmp = ans
        stk = []
        while head:
            stk.append(head)
            head = head.next
            if len(stk) == k:
                for i in range(k):
                    t = stk.pop()
                    tmp.next = t
                    tmp = t
        while stk:
            t = stk.pop(0)
            tmp.next = t
            tmp = t
        tmp.next = None
        return ans.next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;26删除排序数组中的重复项&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/&quot;&gt;26.删除排序数组中的重复项&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个排序数组，原地删除重复出现的元素，返回新数组的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        i = -1
        j = 0
        while j &amp;lt; len(nums):
            if i &amp;lt; 0 or nums[i] != nums[j]:
                i += 1
                nums[i] = nums[j]
            j += 1
        return i+1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;27移除元素&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-element/description/&quot;&gt;27.移除元素&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个数组nums和一个值val，原地移除所有数值等于val的元素，返回新数组的长度。注意，元素的顺序可以改变，不需要考虑数组中超出新长度后面的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def removeElement(self, nums, val):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type val: int
        :rtype: int
        &quot;&quot;&quot;
        i, j, k = 0, len(nums)-1, 0
        while i &amp;lt;= j:
            while i &amp;lt;= j and nums[i] != val:
                i += 1
            while i &amp;lt;= j and nums[j] == val:
                j -= 1
                k += 1
            if i &amp;lt;= j:
                nums[i], nums[j] = nums[j], nums[i]
                k += 1
                i += 1
                j -= 1
        return len(nums)-k
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;28实现strstr&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/description/&quot;&gt;28.实现strstr()&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个haystack字符串和一个needle字符串，在haystack中找出第一次出现needle的位置，如不存在则返回-1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def strStr(self, haystack, needle):
        &quot;&quot;&quot;
        :type haystack: str
        :type needle: str
        :rtype: int
        &quot;&quot;&quot;
        try:
            idx = haystack.index(needle)
        except ValueError:
            idx = -1
        return idx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;29两数相除&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/divide-two-integers/description/&quot;&gt;29.两数相除&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定两个32位有符号的整数，返回它们的商，保证除数不为0。如果溢出，则返回最大值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def divide(self, dividend, divisor):
        &quot;&quot;&quot;
        :type dividend: int
        :type divisor: int
        :rtype: int
        &quot;&quot;&quot;
        ret = abs(dividend) // abs(divisor)
        if dividend * divisor &amp;lt; 0:
            ret = -ret
        ret = min(ret, 2**31-1)
        return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;30与所有单词相关联的字串&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/description/&quot;&gt;30.与所有单词相关联的字串&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个字符串s和一些长度相同的单词words，在s中找出可以恰好串联words中所有单词的子串的起始位置。注意子串要与words中的单词完全匹配，中间不能有其他字符，但顺序不做要求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def findSubstring(self, s, words):
        &quot;&quot;&quot;
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        &quot;&quot;&quot;
        if not words: return []
        std = sorted(words)
        siz = len(words[0])
        cnt = len(words)
        ans = []
        for i in range(0, len(s)-siz*cnt+1):
            tmp = []
            for j in range(i, i+siz*cnt, siz):
                tmp.append(s[j:j+siz])
            tmp.sort()
            if tmp == std:
                ans.append(i)
        return ans
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 01 Jul 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/07/01/leetcode-21-30.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/07/01/leetcode-21-30.html</guid>
        
        
        <category>LeetCode</category>
        
      </item>
    
      <item>
        <title>leetcode 11-20</title>
        <description>&lt;h3 id=&quot;11盛水最多的容器&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/description/&quot;&gt;11.盛水最多的容器&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定n个非负整数a[n]，每个数代表一个点(i,a[i])，画n条垂线，每条垂线的端点分别为(i,a[i])和(i,0)，选两条线，使它们与x轴构成的容器可以容纳最多的水。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def maxArea(self, height):
        &quot;&quot;&quot;
        :type height: List[int]
        :rtype: int
        &quot;&quot;&quot;
        ans = 0
        i, j = 0, len(height)-1
        while i &amp;lt; j:
            ans = max(ans, (j-i)*min(height[i], height[j]))
            if height[i] &amp;lt;= height[j]:
                i += 1
            else:
                j -= 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;12整数转罗马数字&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/integer-to-roman/description/&quot;&gt;12.整数转罗马数字&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在罗马数字表示法中，字母&quot;IVXLCDM&quot;分别代表1, 5, 10, 50, 100, 500, 1000。给定一个1〜3999的整数，将其转成罗马数字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def intToRoman(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: str
        &quot;&quot;&quot;
        a = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]
        b = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M']
        ans = ''
        x = len(a) - 1
        while num &amp;gt; 0:
            if num &amp;gt;= a[x]:
                ans += b[x]
                num -= a[x]
            else:
                x -= 1
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;13罗马数字转整数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/roman-to-integer/description/&quot;&gt;13.罗马数字转整数&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个范围在1〜3999的罗马数字，将其转换成整数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def romanToInt(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        a = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
        ans = 0
        for i in range(len(s)):
            if i+1 &amp;lt; len(s) and a[s[i]] &amp;lt; a[s[i+1]]:
                ans -= a[s[i]]
            else:
                ans += a[s[i]]
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;14最长公共前缀&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-prefix/description/&quot;&gt;14.最长公共前缀&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;输入一个字符串数组，求所有字符串的最长公共前缀。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def longestCommonPrefix(self, strs):
        &quot;&quot;&quot;
        :type strs: List[str]
        :rtype: str
        &quot;&quot;&quot;

        def prefix(a, b):
            ret = ''
            for i, j in zip(a, b):
                if i != j:
                    break
                ret += i
            return ret

        ans = ''
        for i in range(len(strs)):
            if i == 0:
                ans = strs[i]
            else:
                ans = prefix(ans, strs[i])
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;15三数之和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/description/&quot;&gt;15.三数之和&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个包含n个整数的数组nums[n]，判断nums中是否存在三个元素a,b,c使得a+b+c=0？找出所有满足条件且不重复的三元组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def threeSum(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        nums.sort()
        ans = set()
        for i, a in enumerate(nums):
            if i and nums[i] == nums[i-1]:
                continue
            L = i+1
            R = len(nums)-1
            while L &amp;lt; R:
                t = a + nums[L] + nums[R]
                if t &amp;lt; 0:
                    L += 1
                elif t &amp;gt; 0:
                    R -= 1
                else:
                    ans.add((a, nums[L], nums[R]))
                    L += 1
                    R -= 1
        return list(ans)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;16最接近的三数之和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum-closest/description/&quot;&gt;16.最接近的三数之和&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个包括n个整数的数组nums和一个目标值target，找出nums中的三个整数，使得它们的和与target最接近，返回这三个数的和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def threeSumClosest(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        nums.sort()
        ans = sum(nums[:3])
        dif = abs(target - ans)
        for i, a in enumerate(nums):
            if i and nums[i-1] == a:
                continue
            L = i+1
            R = len(nums)-1
            while L &amp;lt; R:
                t = a + nums[L] + nums[R]
                if abs(t-target) &amp;lt; dif:
                    dif = abs(t-target)
                    ans = t
                if t &amp;lt; target:
                    L += 1
                elif t &amp;gt; target:
                    R -= 1
                else:
                    break
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;17电话号码的字母组合&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/&quot;&gt;17.电话号码的字母组合&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在手机上数字2-9的键对应着字母a-z，给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def letterCombinations(self, digits):
        &quot;&quot;&quot;
        :type digits: str
        :rtype: List[str]
        &quot;&quot;&quot;
        if not digits:
            return []
        ans = ['']
        a = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']
        for d in digits:
            ans = [j+i for j in ans for i in a[int(d)]]
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;18四数之和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/4sum/description/&quot;&gt;18.四数之和&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个包含n个整数的数组nums和一个目标值target，判断nums中是否存在四个元素a,b,c,d使得a+b+c+d=target，找出所有满足条件且不重复的四元组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def fourSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        nums.sort()
        ans = set()
        for a, A in enumerate(nums):
            if a and nums[a-1] == A:
                continue
            for b in range(a+1, len(nums)):
                B = nums[b]
                if b-1 &amp;gt; a and nums[b-1] == B:
                    continue
                L = b+1
                R = len(nums)-1
                while L &amp;lt; R:
                    t = A+B+nums[L]+nums[R]
                    if t &amp;lt; target:
                        L += 1
                    elif t &amp;gt; target:
                        R -= 1
                    else:
                        ans.add((A,B,nums[L],nums[R]))
                        L += 1
                        R -= 1
        return list(ans)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;19删除链表的倒数第n个节点&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/&quot;&gt;19.删除链表的倒数第N个节点&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个链表，删除倒数第n个节点，并返回链表的头结点，给定的n保证有效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head, n):
        &quot;&quot;&quot;
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        &quot;&quot;&quot;
        a, b, c = None, head, head
        for i in range(n):
            c = c.next
        while c:
            a, b, c = b, b.next, c.next
        if a:
            a.next = b.next
            return head
        return b.next
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;20有效的括号&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/description/&quot;&gt;20.有效的括号&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个只包含大中小括号的字符串，判断字符串是否有效。注意空字符串有效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def isValid(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        a = []
        tag = {')':'(', ']':'[', '}':'{'}
        for i in s:
            if i in '([{':
                a.append(i)
            else:
                if a and a[-1] == tag[i]:
                    a.pop()
                else:
                    return False
        return len(a) == 0
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 29 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/06/29/leetcode-11-20.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/06/29/leetcode-11-20.html</guid>
        
        
        <category>LeetCode</category>
        
      </item>
    
      <item>
        <title>leetcode 1-10</title>
        <description>&lt;p&gt;为熟悉python，这里选择用它来写LeetCode上的题目练手，在能通过的前提下尽可能地让代码简单清晰。&lt;/p&gt;

&lt;h3 id=&quot;1两数之和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/description/&quot;&gt;1.两数之和&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数，输入保证有唯一解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        ans = []
        a = {}
        for i in range(len(nums)):
            k = target - nums[i]
            if k in a:
                ans.extend([a[k], i])
                break
            a[nums[i]] = i
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2两数相加&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/description/&quot;&gt;2.两数相加&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定两个非空链表来表示两个非负整数，位数按照逆序方式存储，每个节点存一位数字，将两数相加并按该表式法返回结果。注意，数字没有前导0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        c = 0
        ans = []
        while l1 or l2:
            if l1:
                c += l1.val
                l1 = l1.next
            if l2:
                c += l2.val
                l2 = l2.next
            ans.append(t % 10)
            c = c // 10
        if c: ans.append(c)
        node = None
        for i in ans[::-1]:
            t = ListNode(i)
            t.next = node
            node = t
        return node
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3无重复字符的最长子串&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/&quot;&gt;3.无重复字符的最长子串&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个字符串，找出不含有重复字符的最长子串的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def lengthOfLongestSubstring(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        d = {}
        i, j, k = 0, 0, 0
        while j &amp;lt; len(s):
            d[s[j]] = 1 + d.get(s[j], 0)
            while d[s[j]] &amp;gt; 1:
                d[s[i]] -= 1
                i += 1
            k = max(k, j-i+1)
            j += 1
        return k
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4两个排序数组的中位数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/&quot;&gt;4.两个排序数组的中位数&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定两个大小分别为m和n的有序数组nums1与nums2，求这两个有序数组合并后的中位数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        &quot;&quot;&quot;
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        &quot;&quot;&quot;
        nums = nums1 + nums2
        nums.sort()
        l = len(nums)
        return (nums[(l-1)//2] + nums[l//2]) / 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;5最长回文子串&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/description/&quot;&gt;5.最长回文子串&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个字符串s，找到s中任意一个最长的回文子串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def longestPalindrome(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: str
        &quot;&quot;&quot;
        S = '##'
        for i in s:
            S += i + '#'
        M, R, ans = 0, 0, 0
        p = [0] * len(S)
        for i in range(len(S)):
            if i &amp;lt; M:
                p[i] = max(p[2*M-i], R-i)
            else:
                p[i] = 1
            while i-p[i] &amp;gt;= 0 and i+p[i] &amp;lt; len(S) and S[i-p[i]] == S[i+p[i]]:
                p[i] += 1
            if R &amp;lt; i+p[i]:
                M = i
                R = i+p[i]
            if ans &amp;lt; p[i]-1:
                ans = p[i]-1
                z = i
        ret = ss[z-ans+1:z+ans].replace('#', '')
        return ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;6z字形变换&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zigzag-conversion/description/&quot;&gt;6.Z字形变换&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;将字符串以Z字形排列成给定的行数，然后从左往右逐行读取字符得到新串，返回该新串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def convert(self, s, numRows):
        &quot;&quot;&quot;
        :type s: str
        :type numRows: int
        :rtype: str
        &quot;&quot;&quot;
        if numRows &amp;lt; 2: return s
        x, d = 0, 1
        t = [[] for i in range(numRows)]
        for i in s:
            t[x].append(i)
            x = x + d
            if x == numRows - 1:
                d = -1
            elif x == 0:
                d = 1
        ans = ''
        for i in t:
            ans += ''.join(i)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;7反转整数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer/description/&quot;&gt;7.反转整数&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个32位有符号整数，将数字进行反转，如反转后会溢出，则返回0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def reverse(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: int
        &quot;&quot;&quot;
        s = str(x)
        sign = ''
        if s[0] == '-':
            sign = '-'
            s = s[1:]
        ans = sign + s[::-1]
        ans = int(ans)
        if ans &amp;lt; -2**31 or ans &amp;gt; 2**31-1:
            ans = 0
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;8字符串转整数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-integer-atoi/description/&quot;&gt;8.字符串转整数&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;实现类似atoi的功能，将字符串转为整数。要求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;忽略起始的空白字符&lt;/li&gt;
  &lt;li&gt;可以有前导的正负号&lt;/li&gt;
  &lt;li&gt;可以在形成整数的字符后面有多余的字符，将被忽略&lt;/li&gt;
  &lt;li&gt;对于无效字符串，返回0&lt;/li&gt;
  &lt;li&gt;超出INT_MAX或INT_MIN，返回INT_MAX与INT_MIN&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def myAtoi(self, str):
        &quot;&quot;&quot;
        :type str: str
        :rtype: int
        &quot;&quot;&quot;
        s = str.lstrip()
        sign = 0
        ans = 0
        for i, j in enumerate(s):
            if i == 0:
                if j == '-':
                    sign = -1
                elif j == '+':
                    sign = 1
                elif j.isdigit():
                    sign = 1
                    ans = int(j)
                else:
                    return 0
            else:
                if j.isdigit():
                    ans = ans * 10 + int(j)
                else:
                    break
        ans *= sign
        ans = min(ans, 2**31-1)
        ans = max(ans, -2**31)
        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;9回文数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-number/description/&quot;&gt;9.回文数&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;判断一个整数是否是回文数，即正序读和倒序读是一样的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def isPalindrome(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: bool
        &quot;&quot;&quot;
        s = str(x)
        return s == s[::-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;10正则表达式匹配&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/regular-expression-matching/description/&quot;&gt;10.正则表达式匹配&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;给定一个字符串s和一个字符模式p，实现支持点号和星号的正则表达式匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def isMatch(self, s, p):
        &quot;&quot;&quot;
        :type s: str
        :type p: str
        :rtype: bool
        &quot;&quot;&quot;
        p = '^' + p + '$'
        ok = re.match(p, s)
        return True if ok else False
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 26 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/06/26/leetcode-1-10.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/06/26/leetcode-1-10.html</guid>
        
        
        <category>LeetCode</category>
        
      </item>
    
      <item>
        <title>python中的栈和队列</title>
        <description>&lt;p&gt;栈和队列是较常用的数据结构，本文整理了它们在python下的高效实现方法。&lt;/p&gt;

&lt;h3 id=&quot;栈&quot;&gt;栈&lt;/h3&gt;

&lt;p&gt;python内置了list类型，通过它的append和pop方法就可以实现栈的功能，由于各项操作都是O(1)的，速度还算快。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Stack():
    def __init__(self):
        self.data = []
    
    def push(self, item):
        self.data.append(item)

    def top(self):
        return self.data[-1]

    def pop(self):
        self.data.pop()
    
    def empty(self):
        return len(self.data) == 0

    def size(self):
        return len(self.data)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试验证，使用collections模块中的deque来实现栈效率还要高些，deque常用的接口列出如下：&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; style=&quot;width:800px; height:100px; text-align:left&quot; cellpadding=&quot;6&quot;&gt;
&lt;tr&gt;&lt;td&gt;append(x)&lt;/td&gt;&lt;td&gt;add x to the right side of the deque&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;appendleft(x)&lt;/td&gt;&lt;td&gt;add x to the left side of the deque&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;pop()&lt;/td&gt;&lt;td&gt;remove and return an element from the right side of the deque&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;popleft()&lt;/td&gt;&lt;td&gt;remove and return an element from the left side of the deque&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;clear()&lt;/td&gt;&lt;td&gt;remove all elements from the deque&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;count(x)&lt;/td&gt;&lt;td&gt;count the number of elements equal to x&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;len(d)&lt;/td&gt;&lt;td&gt;return number of elements in deque d&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;if d:&lt;/td&gt;&lt;td&gt;check if deque d is empty or not&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p /&gt;

&lt;p&gt;在python中，对于list, tuple, string, dict等类型的对象x，都可以用if x的方式来判断是否为空。&lt;/p&gt;

&lt;p&gt;对于栈，使用append和pop的组合即可实现。&lt;/p&gt;

&lt;h3 id=&quot;队列&quot;&gt;队列&lt;/h3&gt;

&lt;p&gt;可以用list的append/pop(0)或者insert(0)/pop()来实现队列，由于insert(0)和pop(0)是O(n)的，效率不够好，建议直接用标准库collections提供的deque。&lt;/p&gt;

&lt;p&gt;对于队列，使用append和popleft的组合即可实现，当然也可以用appendleft和pop来做。&lt;/p&gt;

&lt;h3 id=&quot;优先队列&quot;&gt;优先队列&lt;/h3&gt;

&lt;p&gt;可以使用list结构自行实现二叉堆，而python库中也有多种实现，经过测试，性能最好的要属heapq模块，建议使用。&lt;/p&gt;

&lt;p&gt;需要注意的是，python提供的二叉堆堆顶元素下标为0，并且默认均是小根堆。&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; style=&quot;width:800px; height:100px; text-align:left&quot; cellpadding=&quot;6&quot;&gt;
&lt;tr&gt;&lt;td&gt;heappush(heap, item)&lt;/td&gt;&lt;td&gt;push item onto heap and maintain heap invariant&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;heap[0]&lt;/td&gt;&lt;td&gt;access the smallest item without popping it&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;heappop(heap)&lt;/td&gt;&lt;td&gt;pop and return the smallest item from heap&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;heapify(x)&lt;/td&gt;&lt;td&gt;transform list x into a heap, in-place, in linear time&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p /&gt;

&lt;h3 id=&quot;性能测试&quot;&gt;性能测试&lt;/h3&gt;

&lt;p&gt;下面编写代码对上述三种数据结构做性能测试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import logging as log
from collections import deque
import heapq

def TestStack(n):
    log.debug('===== begin test stack =====')
    s = deque()
    for i in range(n):
        s.append(i)
    log.debug('stack push ok')
    i = n
    while s:
        i -= 1
        assert(i == s.pop())
    log.debug('stack pop ok')

def TestQueue(n):
    log.debug('===== begin test queue =====')
    q = deque()
    for i in range(n):
        q.append(i)
    log.debug('queue push ok')
    i = 0
    while q:
        assert(i == q.popleft())
        i += 1
    log.debug('queue pop ok')

def TestPriorityQueue(n):
    log.debug('===== begin test priority queue =====')
    pq = []
    for i in range(n):
        heapq.heappush(pq, i)
    log.debug('priority queue push ok')
    i = 0
    while pq:
        assert(i == pq[0])
        heapq.heappop(pq)
        i += 1
    log.debug('priority queue pop ok')

def main():
    log.basicConfig(level=log.DEBUG, format='%(asctime)s - %(message)s')
    N = 1000000
    TestStack(N)
    TestQueue(N)
    TestPriorityQueue(N)

if __name__ == '__main__':
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;某次运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ time python3 z.py 
2018-06-23 15:34:45,030 - ===== begin test stack =====
2018-06-23 15:34:45,175 - stack push ok
2018-06-23 15:34:45,384 - stack pop ok
2018-06-23 15:34:45,384 - ===== begin test queue =====
2018-06-23 15:34:45,521 - queue push ok
2018-06-23 15:34:45,740 - queue pop ok
2018-06-23 15:34:45,740 - ===== begin test priority queue =====
2018-06-23 15:34:46,001 - priority queue push ok
2018-06-23 15:34:46,859 - priority queue pop ok

real       0m1.889s
user       0m1.790s
sys        0m0.078s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行速度非常快，接近C/C++的性能。&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/06/23/queue-and-stack-in-python.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/06/23/queue-and-stack-in-python.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>stl常用容器方法</title>
        <description>&lt;h3 id=&quot;vector&quot;&gt;vector&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;push_back(val)&lt;/li&gt;
  &lt;li&gt;pop_back()&lt;/li&gt;
  &lt;li&gt;empty()&lt;/li&gt;
  &lt;li&gt;size()&lt;/li&gt;
  &lt;li&gt;front()&lt;/li&gt;
  &lt;li&gt;back()&lt;/li&gt;
  &lt;li&gt;insert(pos, val)&lt;/li&gt;
  &lt;li&gt;erase(pos)&lt;/li&gt;
  &lt;li&gt;clear()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stack&quot;&gt;stack&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;push(val)&lt;/li&gt;
  &lt;li&gt;top()&lt;/li&gt;
  &lt;li&gt;pop()&lt;/li&gt;
  &lt;li&gt;empty()&lt;/li&gt;
  &lt;li&gt;size()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;queue&quot;&gt;queue&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;push(val)&lt;/li&gt;
  &lt;li&gt;front()&lt;/li&gt;
  &lt;li&gt;pop()&lt;/li&gt;
  &lt;li&gt;empty()&lt;/li&gt;
  &lt;li&gt;size()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;deque&quot;&gt;deque&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;push_back(val)&lt;/li&gt;
  &lt;li&gt;push_front(val)&lt;/li&gt;
  &lt;li&gt;front()&lt;/li&gt;
  &lt;li&gt;back()&lt;/li&gt;
  &lt;li&gt;pop_back()&lt;/li&gt;
  &lt;li&gt;pop_front()&lt;/li&gt;
  &lt;li&gt;empty()&lt;/li&gt;
  &lt;li&gt;size()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;priority_queue&quot;&gt;priority_queue&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;push(val)&lt;/li&gt;
  &lt;li&gt;top()&lt;/li&gt;
  &lt;li&gt;pop()&lt;/li&gt;
  &lt;li&gt;empty()&lt;/li&gt;
  &lt;li&gt;size()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;list&quot;&gt;list&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;push_back(val)&lt;/li&gt;
  &lt;li&gt;push_front(val)&lt;/li&gt;
  &lt;li&gt;front()&lt;/li&gt;
  &lt;li&gt;back()&lt;/li&gt;
  &lt;li&gt;pop_back()&lt;/li&gt;
  &lt;li&gt;pop_front()&lt;/li&gt;
  &lt;li&gt;insert(pos, val)&lt;/li&gt;
  &lt;li&gt;erase(pos)&lt;/li&gt;
  &lt;li&gt;clear()&lt;/li&gt;
  &lt;li&gt;sort()&lt;/li&gt;
  &lt;li&gt;unique()&lt;/li&gt;
  &lt;li&gt;reverse()&lt;/li&gt;
  &lt;li&gt;remove()&lt;/li&gt;
  &lt;li&gt;remove_if()&lt;/li&gt;
  &lt;li&gt;merge()&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mapmultimapunordered_map&quot;&gt;map/multimap/unordered_map&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;insert(make_pair(key, val))&lt;/li&gt;
  &lt;li&gt;mp[key] = val (for map and unordered_map)&lt;/li&gt;
  &lt;li&gt;erase(key)&lt;/li&gt;
  &lt;li&gt;empty()&lt;/li&gt;
  &lt;li&gt;size()&lt;/li&gt;
  &lt;li&gt;clear()&lt;/li&gt;
  &lt;li&gt;find(key)&lt;/li&gt;
  &lt;li&gt;count(key)&lt;/li&gt;
  &lt;li&gt;lower_bound(key) (for map and multimap)&lt;/li&gt;
  &lt;li&gt;upper_bound(key) (for map and multimap)&lt;/li&gt;
  &lt;li&gt;equal_range(key)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;setmultisetunordered_set&quot;&gt;set/multiset/unordered_set&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;insert(key)&lt;/li&gt;
  &lt;li&gt;erase(key)&lt;/li&gt;
  &lt;li&gt;empty()&lt;/li&gt;
  &lt;li&gt;size()&lt;/li&gt;
  &lt;li&gt;clear()&lt;/li&gt;
  &lt;li&gt;find(key)&lt;/li&gt;
  &lt;li&gt;count(key)&lt;/li&gt;
  &lt;li&gt;lower_bound(key) (for set and multiset)&lt;/li&gt;
  &lt;li&gt;upper_bound(key) (for set and multiset)&lt;/li&gt;
  &lt;li&gt;equal_range(key)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 22 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/06/22/common-stl-containers.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/06/22/common-stl-containers.html</guid>
        
        
        <category>cpp</category>
        
      </item>
    
      <item>
        <title>线性回归之最小二乘法</title>
        <description>&lt;h3 id=&quot;问题描述&quot;&gt;问题描述&lt;/h3&gt;

&lt;p&gt;假设自变量\((X_{1}, X_{2},\cdots,X_{n})\)与因变量\(Y\)之间满足某种线性关系：&lt;/p&gt;

\[Y = \theta_{0} + \theta_{1}X_{1} + \theta_{2}X_{2} + \cdots + \theta_{n}X_{n}\]

&lt;p&gt;为了表示方便，令\(X_{0}=1\)，那么上式可用矩阵的方式简写为：&lt;/p&gt;

\[Y = X^{T}\theta\]

&lt;p&gt;其中\(X\)和\(\theta\)为列向量。&lt;/p&gt;

\[X = 
\begin{bmatrix}
    X_{0} \\
    X_{1} \\
    \cdots \\
    X_{n} \\
\end{bmatrix}
,
\theta =
\begin{bmatrix}
    \theta_{0} \\
    \theta_{1} \\
    \cdots \\
    \theta_{n} \\
\end{bmatrix}\]

&lt;p&gt;现给出\(m\)组样本数据，求参数\(\theta\)，使上述等式关系尽可能得符合各个样本。这是一个典型的线性回归问题，常见的解法是最小二乘法和梯度下降法，这里介绍最小二乘法。&lt;/p&gt;

&lt;h3 id=&quot;最小二乘法&quot;&gt;最小二乘法&lt;/h3&gt;

&lt;p&gt;根据关系式\(Y = X^{T}\theta\)，构造残差函数\(L(\theta)=\frac{1}{2}(X^{T}\theta-Y)^{T}(X^{T}\theta-Y)\)，为了让\(L(\theta)\)取得最小值，令\(L(\theta)\)对\(\theta\)的一阶导数为零，解出\(\theta\)：&lt;/p&gt;

\[\theta = (X^{T}X)^{-1} X^{T} Y\]

&lt;p&gt;可见，通过最小二乘法求解\(\theta\)主要是进行矩阵乘法运算，由于矩阵乘法的时间复杂度是\(O(n^{3})\)级别的，因此只适用于数据量较小的场景。&lt;/p&gt;

&lt;h3 id=&quot;求解实例&quot;&gt;求解实例&lt;/h3&gt;

&lt;p&gt;假设有线性关系\(Y = 9 + 4X_{1} + X_{2} + 2X_{3}\)，下面随机生成一些数据作为样本，用于求解系数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import random

def func(x1, x2, x3):
    return 9 + 4*x1 + x2 + 2*x3

for i in range(5):
    x1 = random.randint(1, 10)
    x2 = random.randint(1, 10)
    x3 = random.randint(1, 10)
    y = func(x1, x2, x3)
    print(y, x1, x2, x3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;某次运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;71 10 8 7
72 10 5 9
42 2 5 10
39 1 8 9
56 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面根据最小二乘法的结论来求解参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import numpy as np
from numpy import dot
from numpy.linalg import inv

X = np.array([[1,10,8,7],[1,10,5,9],[1,2,5,10],[1,1,8,9],[1,6,7,8]])
Y = np.array([[71],[72],[42],[39],[56]])

theta = dot(dot(inv(dot(X.T, X)), X.T), Y)
print(theta)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[9.]
[4.]
[1.]
[2.]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即通过回归分析得到的关系式为：\(Y = 9 + 4X_{1} + X_{2} + 2X_{3}\)，与预期相符。&lt;/p&gt;

&lt;p&gt;再如，假定国内生产总值GDP与消费Consumption、货币供应量MO、进出口总额EM以及投资Investment这4个因素存在某种线性关系，&lt;a href=&quot;/data/yeardata.csv&quot;&gt;这里&lt;/a&gt;提供了一些样本数据，试着量化该线性关系。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import pandas as pd
import numpy as np
from numpy import dot
from numpy.linalg import inv

data = pd.read_csv('yeardata.csv')
X = data.iloc[:, 1:5]
X['X0'] = 1
X = X.iloc[:, [4,0,1,2,3]]
#print(X)
Y = data.iloc[:, 0]
#print(Y)

theta = dot(dot(inv(dot(X.T, X)), X.T), Y)
print(theta)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[-94.51398652   1.32825128   2.06138007   0.38959829   0.11848647]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即\(GDP = -94.514 + 1.328Consumption + 2.061MO + 0.390EM + 0.118Investment\)。&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/06/21/linear-regression-by-least-squares.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/06/21/linear-regression-by-least-squares.html</guid>
        
        
        <category>机器</category>
        
      </item>
    
      <item>
        <title>支持多语言gettext</title>
        <description>&lt;p&gt;有时，程序展现给用户的信息需要支持多种语言，并且允许在语言之间做灵活的切换，最为常见的场景是支持中英文，GNU的gettext是一个支持多语言的成熟解决方案。&lt;/p&gt;

&lt;h3 id=&quot;编程接口&quot;&gt;编程接口&lt;/h3&gt;

&lt;p&gt;使用gettext需要用到的API如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;locale.h&amp;gt;
#include &amp;lt;libintl.h&amp;gt;

char* setlocale(int category, const char *locale);
char* bindtextdomain(const char *domainname, const char *dirname);
char* textdomain(const char *domainname);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mo文件位置一般是dirname/locale/category/domainname.mo。&lt;/li&gt;
  &lt;li&gt;bindtextdomain与textdomain中的domainname参数必须一致，为mo文件的文件名，不带.mo后缀。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用示例&quot;&gt;使用示例&lt;/h3&gt;

&lt;p&gt;以输出hello为例，以下是相关源码hello.c，假设mo文件取名为scott.mo。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;locale.h&amp;gt;
#include &amp;lt;libintl.h&amp;gt;

#define _(str) gettext(str)

int main(int argc, char *argv[]) {
    setlocale(LC_ALL, &quot;&quot;);
    bindtextdomain(&quot;scott&quot;, &quot;lang&quot;);
    textdomain(&quot;scott&quot;);
    puts(_(&quot;hello&quot;));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译时需要链上intl库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -o hello hello.c -g -Wall -lintl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过xgettext工具从代码中自动提取需要翻译的内容，得到scott.po文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ xgettext -k_ hello.c -o scott.po

$ cat  scott.po
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR &amp;lt;EMAIL@ADDRESS&amp;gt;, YEAR.
#
#, fuzzy
msgid &quot;&quot;
msgstr &quot;&quot;
&quot;Project-Id-Version: PACKAGE VERSION\n&quot;
&quot;Report-Msgid-Bugs-To: \n&quot;
&quot;POT-Creation-Date: 2018-06-19 10:17+0800\n&quot;
&quot;PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n&quot;
&quot;Last-Translator: FULL NAME &amp;lt;EMAIL@ADDRESS&amp;gt;\n&quot;
&quot;Language-Team: LANGUAGE &amp;lt;LL@li.org&amp;gt;\n&quot;
&quot;Language: \n&quot;
&quot;MIME-Version: 1.0\n&quot;
&quot;Content-Type: text/plain; charset=CHARSET\n&quot;
&quot;Content-Transfer-Encoding: 8bit\n&quot;

#: hello.c:11
msgid &quot;hello&quot;
msgstr &quot;&quot;

$ mkdir -p lang/{en_US,zh_CN}/LC_MESSAGES
$ cp scott.po lang/en_US/LC_MESSAGES
$ cp scott.po lang/zh_CN/LC_MESSAGES
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改各po文件的msgstr项，设成翻译后的内容。作为例子，这里生成了zh_CN和en_US两个po文件，其中zh_CN的scott.po里msgstr置成”say hello in chinese”, 而en_US的scott.po设为”say hello in english”。另外，默认生成的po文件charset未设置，建议改成UTF-8。&lt;/p&gt;

&lt;p&gt;接着根据po文本文件成mo二进制文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ msgfmt scott.po -o scott.mo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，运行程序，将根据当前语言输出对应的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo $LANG
zh_CN.UTF-8
$ ./hello 
say hello in chinese
$ export LANG=en_US
$ ./hello 
say hello in english
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 18 Jun 2018 00:00:00 +0800</pubDate>
        <link>http://0.0.0.0:4000/2018/06/18/gettext.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/2018/06/18/gettext.html</guid>
        
        
        <category>平台</category>
        
      </item>
    
  </channel>
</rss>
