<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://chenfy27.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://chenfy27.github.io/" rel="alternate" type="text/html" /><updated>2023-09-12T22:52:18+08:00</updated><id>https://chenfy27.github.io/feed.xml</id><title type="html">陈方勇的网络笔记</title><subtitle>陈方勇的网络笔记
</subtitle><author><name>chenfy27</name></author><entry><title type="html">leetcode 51-60</title><link href="https://chenfy27.github.io/2018/08/11/leetcode-51-60.html" rel="alternate" type="text/html" title="leetcode 51-60" /><published>2018-08-11T00:00:00+08:00</published><updated>2018-08-11T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/08/11/leetcode-51-60</id><content type="html" xml:base="https://chenfy27.github.io/2018/08/11/leetcode-51-60.html"><![CDATA[<h3 id="51n皇后"><a href="https://leetcode-cn.com/problems/n-queens/description/">51.N皇后</a></h3>

<p>将n个皇后放在nxn的棋盘上，使皇后之间不能相互攻击，求所有可行解。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        
        def ok(x, y, tab, n):
            for i in range(x):
                if tab[i][y] == 'Q':
                    return False
            i, j = x-1, y-1
            while i &gt;= 0 and j &gt;= 0:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            i, j = x-1, y+1
            while i &gt;= 0 and j &lt; n:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True
        
        def dfs(x, tab, ans, n):
            if x == n:
                t = []
                for i in tab:
                    t.append(''.join(i))
                ans.append(t)
                return
            for y in range(n):
                if ok(x, y, tab, n):
                    tab[x][y] = 'Q'
                    dfs(x+1, tab, ans, n)
                    tab[x][y] = '.'
        
        ans = []
        tab = [['.' for i in range(n)] for j in range(n)]
        dfs(0, tab, ans, n)
        return ans
</code></pre></div></div>

<h3 id="52n皇后ii"><a href="https://leetcode-cn.com/problems/n-queens-ii/description/">52.N皇后II</a></h3>

<p>将n个皇后放在nxn的棋盘上，使皇后之间不能相互攻击，求所有解的数量。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def totalNQueens(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        def ok(x, y, tab, n):
            for i in range(x):
                if tab[i][y] == 'Q':
                    return False
            i, j = x-1, y-1
            while i &gt;= 0 and j &gt;= 0:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            i, j = x-1, y+1
            while i &gt;= 0 and j &lt; n:
                if tab[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True
        
        def dfs(x, tab, n, ans):
            if x == n:
                ans.append(1)
                return
            for y in range(n):
                if ok(x, y, tab, n):
                    tab[x][y] = 'Q'
                    dfs(x+1, tab, n, ans)
                    tab[x][y] = '.'
        
        ans = []
        tab = [['.' for i in range(n)] for j in range(n)]
        dfs(0, tab, n, ans)
        return len(ans)
</code></pre></div></div>

<h3 id="53最大子序和"><a href="https://leetcode-cn.com/problems/maximum-subarray/description/">53.最大子序和</a></h3>

<p>给定一个非空的整数数组，找出一个具有最大和的连续非空子数组，返回其最大和。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [nums[0]]
        for i in range(1, len(nums)):
            dp.append(max(nums[i], nums[i]+dp[i-1]))
        return max(dp)
</code></pre></div></div>

<h3 id="54螺旋矩阵"><a href="https://leetcode-cn.com/problems/spiral-matrix/description/">54.螺旋矩阵</a></h3>

<p>给定一个包含mxn个元素的矩阵，按顺时针螺旋顺序，返回矩阵中的所有元素。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        ans = []
        if not matrix: return []
        m, n = len(matrix), len(matrix[0])
        tab = [[0 for i in range(n)] for j in range(m)]
        x, y = 0, -1
        while len(ans) &lt; m*n:
            while y+1 &lt; n and tab[x][y+1] == 0:
                y += 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
            while x+1 &lt; m and tab[x+1][y] == 0:
                x += 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
            while y-1 &gt;= 0 and tab[x][y-1] == 0:
                y -= 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
            while x-1 &gt;= 0 and tab[x-1][y] == 0:
                x -= 1
                ans.append(matrix[x][y])
                tab[x][y] = 1
        return ans
</code></pre></div></div>

<h3 id="55跳跃游戏"><a href="https://leetcode-cn.com/problems/jump-game/description/">55.跳跃游戏</a></h3>

<p>给定一个非负整数数组，最初位于第一个位置，数组中每个元素代表在该位置可以跳跃的最大长度，判断是否能够到达最后一个位置。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        mx = 0
        for i, x in enumerate(nums):
            if i &gt; mx:
                return False
            mx = max(mx, i+nums[i])
        return True
</code></pre></div></div>

<h3 id="56合并区间"><a href="https://leetcode-cn.com/problems/merge-intervals/description/">56.合并区间</a></h3>

<p>给出一个区间的集合，合并所有重叠的区间。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for an interval.
# class Interval:
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution:
    def merge(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: List[Interval]
        """
        intervals.sort(key = lambda x: x.start)
        ans = []
        t = None
        for i in intervals:
            if t is None:
                t = i
            else:
                if t.end &gt;= i.start:
                    t.end = max(t.end, i.end)
                else:
                    ans.append(t)
                    t = i
        if t:
            ans.append(t)
        return ans
</code></pre></div></div>

<h3 id="57插入区间"><a href="https://leetcode-cn.com/problems/insert-interval/description/">57.插入区间</a></h3>

<p>给出一个元重复的，按照区间起始端点排序的区间列表，在列表中插入一个新的区间，要确保插完后新的列表中的区间仍然有序且不重复（如有必果，可以合并区间）。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for an interval.
# class Interval:
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution:
    def insert(self, intervals, newInterval):
        """
        :type intervals: List[Interval]
        :type newInterval: Interval
        :rtype: List[Interval]
        """
        intervals.append(newInterval)
        intervals.sort(key = lambda x: x.start)
        ans = []
        t = None
        for i in intervals:
            if t is None:
                t = i
            else:
                if t.end &gt;= i.start:
                    t.end = max(t.end, i.end)
                else:
                    ans.append(t)
                    t = i
        if t: ans.append(t)
        return ans
</code></pre></div></div>

<h3 id="58最后一个单词的长度"><a href="https://leetcode-cn.com/problems/length-of-last-word/description/">58.最后一个单词的长度</a></h3>

<p>给定一个仅包含大小写字母和空格的字符串，返回其最后一个单词的长度。如不存在最后一个单词，返回0.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def lengthOfLastWord(self, s):
        """
        :type s: str
        :rtype: int
        """
        w = s.split()
        return len(w[-1]) if w else 0
</code></pre></div></div>

<h3 id="59螺旋矩阵ii"><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/description/">59.螺旋矩阵II</a></h3>

<p>给定一个正整数n，生成一个包含1到n*n所有元素，且元素按顺时针螺旋排列的方形矩阵。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        ans = [[0 for i in range(n)] for j in range(n)]
        x, y = 0, -1
        cnt = 0
        while cnt &lt; n*n:
            while y+1 &lt; n and ans[x][y+1] == 0:
                y += 1
                cnt += 1
                ans[x][y] = cnt
            while x+1 &lt; n and ans[x+1][y] == 0:
                x += 1
                cnt += 1
                ans[x][y] = cnt
            while y-1 &gt;= 0 and ans[x][y-1] == 0:
                y -= 1
                cnt += 1
                ans[x][y] = cnt
            while x-1 &gt;= 0 and ans[x-1][y] == 0:
                x -= 1
                cnt += 1
                ans[x][y] = cnt
        return ans
</code></pre></div></div>

<h3 id="60第k个排列"><a href="https://leetcode-cn.com/problems/permutation-sequence/description/">60.第k个排列</a></h3>

<p>给出集合[1,2,3,…,n]，其所有元素共有n!种排列，求第k小的排列。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def getPermutation(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        z = [i for i in range(1, n+1)]
        p = 1
        for i in range(1,n):
            p *= i
        k -= 1
        ans = ''
        for i in range(n):
            x, y = divmod(k, p)
            ans += str(z.pop(x))
            k = y
            if n-1 &gt; i:
                p //= n-1-i
        return ans
</code></pre></div></div>]]></content><author><name>chenfy27</name></author><category term="LeetCode" /><summary type="html"><![CDATA[51.N皇后]]></summary></entry><entry><title type="html">leetcode 41-50</title><link href="https://chenfy27.github.io/2018/08/10/leetcode-41-50.html" rel="alternate" type="text/html" title="leetcode 41-50" /><published>2018-08-10T00:00:00+08:00</published><updated>2018-08-10T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/08/10/leetcode-41-50</id><content type="html" xml:base="https://chenfy27.github.io/2018/08/10/leetcode-41-50.html"><![CDATA[<h3 id="41缺失的第一个正整数"><a href="https://leetcode-cn.com/problems/first-missing-positive/description/">41.缺失的第一个正整数</a></h3>

<p>给定一个未排序的整数数组，找出其中没有出现的最小正整数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def firstMissingPositive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        s = set(nums)
        i = 1
        while i in s:
            i += 1
        return i
</code></pre></div></div>

<h3 id="42接雨水"><a href="https://leetcode-cn.com/problems/trapping-rain-water/description/">42.接雨水</a></h3>

<p>给定n个非负整数表示每个宽度为1的柱子的高度图，计算按此排列的柱子，下雨之后能接多少水。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        n = len(height)
        height.insert(0, 0)
        height.append(0)
        L = [0] * (n+5)
        R = [0] * (n+5)
        for i in range(1, n+1):
            L[i] = max(L[i-1], height[i])
        for i in range(n, 0, -1):
            R[i] = max(R[i+1], height[i])
        ans = 0
        for i in range(1, n+1):
            ans += max(0, min(L[i-1], R[i+1]) - height[i])
        return ans
</code></pre></div></div>

<h3 id="43字符串相乘"><a href="https://leetcode-cn.com/problems/multiply-strings/description/">43.字符串相乘</a></h3>

<p>给定两个以字符串形式表示的非负整数num1和num2，求其乘积，也用字符串表示。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        return str(int(num1) * int(num2))
</code></pre></div></div>

<h3 id="44-通配符匹配"><a href="https://leetcode-cn.com/problems/wildcard-matching/description/">44. 通配符匹配</a></h3>

<p>给定一个字符串s和一个字符模式p，实现一个支持'?'和'*'的通配匹配。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution(object):
    def isMatch(self, s, p):
        ls, lp = len(s), len(p)
        dp = [[False for c in range(ls+1)] for r in range(lp+1)]
        dp[0][0] = True
        for i in range(1, lp+1):
            dp[i][0] = p[i-1] == '*' and dp[i-1][0]
        for i in range(1, lp+1):
            for j in range(1, ls+1):
                if p[i-1] == s[j-1] or p[i-1] == '?':
                    dp[i][j] = dp[i-1][j-1]
                elif p[i-1] == '*':
                    dp[i][j] = dp[i-1][j] or dp[i][j-1]
        return dp[lp][ls]
</code></pre></div></div>

<h3 id="45跳跃游戏"><a href="https://leetcode-cn.com/problems/jump-game-ii/description/">45.跳跃游戏</a></h3>

<p>给定一个非负整数数组，最初位于数组的第一个位置，数组中每个元素代表在该位置可以跳跃的最大长度，用最少的步数到达最后一个位置。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def jump(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        C, R = 0, 0
        ans = 0
        for i, j in enumerate(nums):
            if i &gt; C:
                ans += 1
                C = R
            R = max(R, i+j)
        return ans
</code></pre></div></div>

<h3 id="46全排列"><a href="https://leetcode-cn.com/problems/permutations/description/">46.全排列</a></h3>

<p>给定一个没有重复数字的序列，返回其所有可能的全排列。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        
        def dfs(idx, tmp, nums, ans):
            if idx == len(nums):
                ans.append(tmp[::])
                return
            for i in range(idx, len(nums)):
                nums[idx], nums[i] = nums[i], nums[idx]
                dfs(idx+1, tmp+[nums[idx]], nums, ans)
                nums[idx], nums[i] = nums[i], nums[idx]
            
        ans = []
        dfs(0, [], nums, ans)
        return sorted(ans)
</code></pre></div></div>

<h3 id="47全排列ii"><a href="https://leetcode-cn.com/problems/permutations-ii/description/">47.全排列II</a></h3>

<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        def dfs(idx, tmp, nums, ans):
            if idx == len(nums):
                ans.add(tuple(tmp))
                return
            for i in range(idx, len(nums)):
                nums[idx], nums[i] = nums[i], nums[idx]
                dfs(idx+1, tmp+[nums[idx]], nums, ans)
                nums[idx], nums[i] = nums[i], nums[idx]
        
        ans = set()
        dfs(0, [], nums, ans)
        return sorted(list(ans))
</code></pre></div></div>

<h3 id="48旋转图像"><a href="https://leetcode-cn.com/problems/rotate-image/description/">48.旋转图像</a></h3>

<p>给定一个nxn的二维矩阵表示一个图像，将图像顺时针旋转90度。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n):
            for j in range(i+1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for i in range(n):
            L, R = 0, n-1
            while L &lt; R:
                matrix[i][L], matrix[i][R] = matrix[i][R], matrix[i][L]
                L += 1
                R -= 1
</code></pre></div></div>

<h3 id="49字母异位词分组"><a href="https://leetcode-cn.com/problems/group-anagrams/description/">49.字母异位词分组</a></h3>

<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        mp = {}
        for i in strs:
            k = ''.join(sorted(i))
            if k in mp:
                mp[k].append(i)
            else:
                mp[k] = [i]
        ans = []
        for v in mp.values():
            ans.append(v)
        return ans
</code></pre></div></div>

<h3 id="50求幂"><a href="https://leetcode-cn.com/problems/powx-n/description/">50.求幂</a></h3>

<p>实现pow(x,n)，即计算x的n次幂。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        return pow(x, n)
</code></pre></div></div>]]></content><author><name>chenfy27</name></author><category term="LeetCode" /><summary type="html"><![CDATA[41.缺失的第一个正整数]]></summary></entry><entry><title type="html">leetcode 31-40</title><link href="https://chenfy27.github.io/2018/07/02/leetcode-31-40.html" rel="alternate" type="text/html" title="leetcode 31-40" /><published>2018-07-02T00:00:00+08:00</published><updated>2018-07-02T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/07/02/leetcode-31-40</id><content type="html" xml:base="https://chenfy27.github.io/2018/07/02/leetcode-31-40.html"><![CDATA[<h3 id="31下一个排列"><a href="https://leetcode-cn.com/problems/next-permutation/description/">31.下一个排列</a></h3>

<p>给出一组由正整数构成的序列，要求重排得到字典序中下一个更大的排列，如不存在则排成最小排列，要求原地修改。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:        
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        
        def reverse(nums, L, R):
            while L &lt; R:
                nums[L], nums[R] = nums[R], nums[L]
                L += 1
                R -= 1
        
        x = len(nums)-2
        while x &gt;= 0 and nums[x] &gt;= nums[x+1]:
            x -= 1
        if x &lt; 0:
            reverse(nums, 0, len(nums)-1)
        else:
            y = len(nums)-1
            while nums[y] &lt;= nums[x]:
                y -= 1
            nums[x], nums[y] = nums[y], nums[x]
            reverse(nums, x+1, len(nums)-1)
</code></pre></div></div>

<h3 id="32最长有效括号"><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/description/">32.最长有效括号</a></h3>

<p>给定一个只包含'('和')'的字符串，找出最长的包含有效括号的子串的长度。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def longestValidParentheses(self, s):
        """
        :type s: str
        :rtype: int
        """
        stk = []
        dp = [0] * (len(s)+1)
        for i, j in enumerate(s):
            if j == '(':
                stk.append(i)
            else:
                if stk:
                    t = stk.pop()
                    dp[i] = i-t+1
                    if t: dp[i] += dp[t-1]
        return max(dp)
</code></pre></div></div>

<h3 id="33搜索旋转数组"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">33.搜索旋转数组</a></h3>

<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转，现要在数组中搜索一个给定的目标值，如果存在则返回索引，不存在返回-1。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        
        def find1(L, R, nums, target):
            if L &gt; R: return -1
            if nums[L] &lt;= nums[R]:
                return find2(L, R, nums, target)
            M = L + (R-L) // 2
            if nums[L] &lt;= nums[M]:
                if nums[L] &lt;= target &lt;= nums[M]:
                    return find2(L, M, nums, target)
                return find1(M+1, R, nums, target)
            else:
                if nums[M] &lt;= target &lt;= nums[R]:
                    return find2(M, R, nums, target)
                return find1(L, M-1, nums, target)

        def find2(L, R, nums, target):
            lo, hi = L, R
            while lo &lt;= hi:
                mid = lo + (hi-lo) // 2
                if nums[mid] &lt; target:
                    lo = mid+1
                elif nums[mid] &gt; target:
                    hi = mid-1
                else:
                    return mid
            return -1

        return find1(0, len(nums)-1, nums, target)
</code></pre></div></div>

<h3 id="34搜索范围"><a href="https://leetcode-cn.com/problems/search-for-a-range/description/">34.搜索范围</a></h3>

<p>给定一个按照升序排列的整数数组和一个目标值，找出给定目标值在数组中的开始位置和结束位置，如不存在，则返回[-1,-1]。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        
        def find1(nums, target):
            if not nums: return -1
            lo, hi = 0, len(nums)-1
            while lo &lt; hi:
                mid = lo + (hi-lo) // 2
                if nums[mid] &lt; target:
                    lo = mid+1
                elif nums[mid] &gt; target:
                    hi = mid-1
                else:
                    hi = mid
            if lo &lt; len(nums) and nums[lo] == target:
                return lo
            return -1

        def find2(nums, target):
            if not nums: return -1
            lo, hi = 0, len(nums)-1
            while lo &lt; hi:
                mid = lo + (hi-lo+1) // 2
                if nums[mid] &lt; target:
                    lo = mid+1
                elif nums[mid] &gt; target:
                    hi = mid-1
                else:
                    lo = mid
            if lo &lt; len(nums) and nums[lo] == target:
                return lo
            return -1
    
        L = find1(nums, target)
        R = find2(nums, target)
        return [L, R]
</code></pre></div></div>

<h3 id="35搜索插入位置"><a href="https://leetcode-cn.com/problems/search-insert-position/description/">35.搜索插入位置</a></h3>

<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果不存在，则返回它将会被按顺序插入的位置。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if not nums: return 0
        lo, hi = 0, len(nums)-1
        while lo &lt; hi:
            mid = lo + (hi - lo) // 2
            if nums[mid] &lt; target:
                lo = mid+1
            else:
                hi = mid
        if lo &lt; len(nums) and nums[lo] &gt;= target:
            return lo
        return lo+1
</code></pre></div></div>

<h3 id="36有效的数独"><a href="https://leetcode-cn.com/problems/valid-sudoku/description/">36.有效的数独</a></h3>

<p>判断一个9x9的数独是否有效，注意给定的数独序列只包含数字1-9和字符'.'，一个有效的数独不一定是可解的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def isValidSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: bool
        """
        def ok(T):
            s = set()
            for i in T:
                if i == '.': continue
                if i in s: return False
                s.add(i)
            return True
        
        for i in range(9):
            t = []
            for j in range(9):
                t.append(board[i][j])
            if not ok(t):
                return False

        for j in range(9):
            t = []
            for i in range(9):
                t.append(board[i][j])
            if not ok(t):
                return False
            
        for i in range(0,9,3):
            for j in range(0,9,3):
                t = []
                for x in range(3):
                    for y in range(3):
                        t.append(board[i+x][j+y])
                if not ok(t):
                    return False
        return True
</code></pre></div></div>

<h3 id="37解数独"><a href="https://leetcode-cn.com/problems/sudoku-solver/description/">37.解数独</a></h3>

<p>给定一个只包含数字1-9和字符'.'的数独序列，其中'.'代表未确定的数字，解出该数独。输入保证有唯一解。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def solveSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        
        def ok(T):
            s = set()
            for i in T:
                if i == '.': continue
                if i in s: return False
                s.add(i)
            return True
        
        def checkH(x):
            t = []
            for i in range(9):
                t.append(board[x][i])
            return ok(t)
        
        def checkV(y):
            t = []
            for i in range(9):
                t.append(board[i][y])
            return ok(t)
        
        def checkB(x, y):
            t = []
            for i in range(3):
                for j in range(3):
                    t.append(board[x+i][y+j])
            return ok(t)
        
        def check(x, y):
            return checkH(x) and checkV(y) and checkB(x//3*3, y//3*3)

        def dfs(n):
            if n == 81: return True
            x, y = n//9, n%9
            if board[x][y] != '.':
                return dfs(n+1)
            for i in range(1,10):
                board[x][y] = str(i)
                if check(x, y):
                    if dfs(n+1):
                        return True
            board[x][y] = '.'
            return False
        
        dfs(0)
</code></pre></div></div>

<h3 id="38报数"><a href="https://leetcode-cn.com/problems/count-and-say/description/">38.报数</a></h3>

<p>报数序列是指一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。给定一个正整数n，输出报数序列的第n项。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def countAndSay(self, n):
        """
        :type n: int
        :rtype: str
        """
        ans = '1'
        for i in range(1, n):
            tmp = ''
            idx = 0
            while idx &lt; len(ans):
                tag = ans[idx]
                cnt = 0
                while idx &lt; len(ans) and ans[idx] == tag:
                    idx += 1
                    cnt += 1
                tmp += str(cnt) + tag
            ans = tmp
        return ans
</code></pre></div></div>

<h3 id="39组合求和"><a href="https://leetcode-cn.com/problems/combination-sum/description/">39.组合求和</a></h3>

<p>给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合，注意candidates中的数字可以无限制重复被选取，保证candidates中的数以及target都是正整数。输出结果要求不能包含重复的组合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        
        def dfs(idx, cur, tmp, ans, candidates, target):
            if cur &gt; target: return
            if cur == target:
                ans.append(tmp.copy())
                return
            if idx == len(candidates):
                return
            dfs(idx+1, cur, tmp+[candidates[idx]], ans, candidates, target)
            dfs(idx, cur+candidates[idx], tmp, ans, candidates, target)
        
        ans = []
        dfs(0, 0, [], ans, candidates, target)
        return ans
</code></pre></div></div>

<h3 id="40组合总和ii"><a href="https://leetcode-cn.com/problems/combination-sum-ii/description/">40.组合总和II</a></h3>

<p>给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合，注意candidates中的数字在每个组合中最多只能使用一次，保证candidates中的数以及target都是正整数，要求解集不能包含重复的组合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        
        def dfs(idx, cur, tmp, ans, candidates, target):
            if cur &gt; target: return
            if cur == target:
                ans.add(tuple(tmp))
                return
            if idx == len(candidates):
                return
            dfs(idx+1, cur, tmp, ans, candidates, target)
            dfs(idx+1, cur+candidates[idx], tmp+[candidates[idx]], ans, candidates, target)

        ans = set()
        candidates.sort()
        dfs(0, 0, [], ans, candidates, target)
        return sorted(list(ans))
</code></pre></div></div>]]></content><author><name>chenfy27</name></author><category term="LeetCode" /><summary type="html"><![CDATA[31.下一个排列]]></summary></entry><entry><title type="html">leetcode 21-30</title><link href="https://chenfy27.github.io/2018/07/01/leetcode-21-30.html" rel="alternate" type="text/html" title="leetcode 21-30" /><published>2018-07-01T00:00:00+08:00</published><updated>2018-07-01T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/07/01/leetcode-21-30</id><content type="html" xml:base="https://chenfy27.github.io/2018/07/01/leetcode-21-30.html"><![CDATA[<h3 id="21合并两个有序链表"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/">21.合并两个有序链表</a></h3>

<p>将两个有序链表合并为一个新的有序链表并返回。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        ans = ListNode(0)
        tmp = ans
        while l1 and l2:
            if l1.val &lt;= l2.val:
                tmp.next = l1
                tmp = l1
                l1 = l1.next
            else:
                tmp.next = l2
                tmp = l2
                l2 = l2.next
        if l1: tmp.next = l1
        if l2: tmp.next = l2
        return ans.next
</code></pre></div></div>

<h3 id="22括号生成"><a href="https://leetcode-cn.com/problems/generate-parentheses/description/">22.括号生成</a></h3>

<p>给出n代表生成括号的对数，要求生成所有可能并且有效的括号组合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """

        def dfs(L, R, s, ans):
            if L &lt; 0 or R &lt; 0 or L &gt; R:
                return
            if L == 0 and R == 0:
                ans.append(s)
                return
            dfs(L-1, R, s+'(', ans)
            dfs(L, R-1, s+')', ans)

        ans = []
        dfs(n, n, '', ans)
        return ans
</code></pre></div></div>

<h3 id="23合并k个排序链表"><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/description/">23.合并K个排序链表</a></h3>

<p>合并K个排序链表，返回合并后的排序链表。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """

        def merge(self, A, B):
            X = ListNode(0)
            t = X
            while A and B:
                if A.val &lt;= B.val:
                    t.next = A
                    t = A
                    A = A.next
                else:
                    t.next = B
                    t = B
                    B = B.next
            if A: t.next = A
            if B: t.next = B
            return X.next

        ans = []
        if not lists: return ans
        while len(lists) &gt; 1:
            for i in range(0, len(lists), 2):
                j = i+1
                if j &lt; len(lists):
                    t = merge(lists[i], lists[j])
                    ans.append(t)
                else:
                    ans.append(lists[i])
            lists = ans
            ans = []
        return lists[0]
</code></pre></div></div>

<h3 id="24两两交换链表中的节点"><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/">24.两两交换链表中的节点</a></h3>

<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        ans = ListNode(0)
        tmp = ans
        stk = []
        while head:
            stk.append(head)
            head = head.next
            if len(stk) == 2:
                for j in range(2):
                    t = stk.pop()
                    tmp.next = t
                    tmp = t
        while stk:
            t = stk.pop()
            tmp.next = t
            tmp = t
        tmp.next = None
        return ans.next
</code></pre></div></div>

<h3 id="25k个一组翻转链表"><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/">25.K个一组翻转链表</a></h3>

<p>给出一个链表，每K个节点一组进行翻转，并返回翻转后的链表。K为正整数，它的值不超过链表长度。如果节点数不是K的倍数，那么最后整余节点保持原来的顺序。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        ans = ListNode(0)
        tmp = ans
        stk = []
        while head:
            stk.append(head)
            head = head.next
            if len(stk) == k:
                for i in range(k):
                    t = stk.pop()
                    tmp.next = t
                    tmp = t
        while stk:
            t = stk.pop(0)
            tmp.next = t
            tmp = t
        tmp.next = None
        return ans.next
</code></pre></div></div>

<h3 id="26删除排序数组中的重复项"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/">26.删除排序数组中的重复项</a></h3>

<p>给定一个排序数组，原地删除重复出现的元素，返回新数组的长度。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = -1
        j = 0
        while j &lt; len(nums):
            if i &lt; 0 or nums[i] != nums[j]:
                i += 1
                nums[i] = nums[j]
            j += 1
        return i+1
</code></pre></div></div>

<h3 id="27移除元素"><a href="https://leetcode-cn.com/problems/remove-element/description/">27.移除元素</a></h3>

<p>给定一个数组nums和一个值val，原地移除所有数值等于val的元素，返回新数组的长度。注意，元素的顺序可以改变，不需要考虑数组中超出新长度后面的元素。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        i, j, k = 0, len(nums)-1, 0
        while i &lt;= j:
            while i &lt;= j and nums[i] != val:
                i += 1
            while i &lt;= j and nums[j] == val:
                j -= 1
                k += 1
            if i &lt;= j:
                nums[i], nums[j] = nums[j], nums[i]
                k += 1
                i += 1
                j -= 1
        return len(nums)-k
</code></pre></div></div>

<h3 id="28实现strstr"><a href="https://leetcode-cn.com/problems/implement-strstr/description/">28.实现strstr()</a></h3>

<p>给定一个haystack字符串和一个needle字符串，在haystack中找出第一次出现needle的位置，如不存在则返回-1。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        try:
            idx = haystack.index(needle)
        except ValueError:
            idx = -1
        return idx
</code></pre></div></div>

<h3 id="29两数相除"><a href="https://leetcode-cn.com/problems/divide-two-integers/description/">29.两数相除</a></h3>

<p>给定两个32位有符号的整数，返回它们的商，保证除数不为0。如果溢出，则返回最大值。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def divide(self, dividend, divisor):
        """
        :type dividend: int
        :type divisor: int
        :rtype: int
        """
        ret = abs(dividend) // abs(divisor)
        if dividend * divisor &lt; 0:
            ret = -ret
        ret = min(ret, 2**31-1)
        return ret
</code></pre></div></div>

<h3 id="30与所有单词相关联的字串"><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/description/">30.与所有单词相关联的字串</a></h3>

<p>给定一个字符串s和一些长度相同的单词words，在s中找出可以恰好串联words中所有单词的子串的起始位置。注意子串要与words中的单词完全匹配，中间不能有其他字符，但顺序不做要求。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def findSubstring(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """
        if not words: return []
        std = sorted(words)
        siz = len(words[0])
        cnt = len(words)
        ans = []
        for i in range(0, len(s)-siz*cnt+1):
            tmp = []
            for j in range(i, i+siz*cnt, siz):
                tmp.append(s[j:j+siz])
            tmp.sort()
            if tmp == std:
                ans.append(i)
        return ans
</code></pre></div></div>]]></content><author><name>chenfy27</name></author><category term="LeetCode" /><summary type="html"><![CDATA[21.合并两个有序链表]]></summary></entry><entry><title type="html">leetcode 11-20</title><link href="https://chenfy27.github.io/2018/06/29/leetcode-11-20.html" rel="alternate" type="text/html" title="leetcode 11-20" /><published>2018-06-29T00:00:00+08:00</published><updated>2018-06-29T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/06/29/leetcode-11-20</id><content type="html" xml:base="https://chenfy27.github.io/2018/06/29/leetcode-11-20.html"><![CDATA[<h3 id="11盛水最多的容器"><a href="https://leetcode-cn.com/problems/container-with-most-water/description/">11.盛水最多的容器</a></h3>

<p>给定n个非负整数a[n]，每个数代表一个点(i,a[i])，画n条垂线，每条垂线的端点分别为(i,a[i])和(i,0)，选两条线，使它们与x轴构成的容器可以容纳最多的水。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        ans = 0
        i, j = 0, len(height)-1
        while i &lt; j:
            ans = max(ans, (j-i)*min(height[i], height[j]))
            if height[i] &lt;= height[j]:
                i += 1
            else:
                j -= 1
        return ans
</code></pre></div></div>

<h3 id="12整数转罗马数字"><a href="https://leetcode-cn.com/problems/integer-to-roman/description/">12.整数转罗马数字</a></h3>

<p>在罗马数字表示法中，字母"IVXLCDM"分别代表1, 5, 10, 50, 100, 500, 1000。给定一个1〜3999的整数，将其转成罗马数字。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def intToRoman(self, num):
        """
        :type num: int
        :rtype: str
        """
        a = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]
        b = ['I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM', 'M']
        ans = ''
        x = len(a) - 1
        while num &gt; 0:
            if num &gt;= a[x]:
                ans += b[x]
                num -= a[x]
            else:
                x -= 1
        return ans
</code></pre></div></div>

<h3 id="13罗马数字转整数"><a href="https://leetcode-cn.com/problems/roman-to-integer/description/">13.罗马数字转整数</a></h3>

<p>给定一个范围在1〜3999的罗马数字，将其转换成整数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        a = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}
        ans = 0
        for i in range(len(s)):
            if i+1 &lt; len(s) and a[s[i]] &lt; a[s[i+1]]:
                ans -= a[s[i]]
            else:
                ans += a[s[i]]
        return ans
</code></pre></div></div>

<h3 id="14最长公共前缀"><a href="https://leetcode-cn.com/problems/longest-common-prefix/description/">14.最长公共前缀</a></h3>

<p>输入一个字符串数组，求所有字符串的最长公共前缀。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """

        def prefix(a, b):
            ret = ''
            for i, j in zip(a, b):
                if i != j:
                    break
                ret += i
            return ret

        ans = ''
        for i in range(len(strs)):
            if i == 0:
                ans = strs[i]
            else:
                ans = prefix(ans, strs[i])
        return ans
</code></pre></div></div>

<h3 id="15三数之和"><a href="https://leetcode-cn.com/problems/3sum/description/">15.三数之和</a></h3>

<p>给定一个包含n个整数的数组nums[n]，判断nums中是否存在三个元素a,b,c使得a+b+c=0？找出所有满足条件且不重复的三元组。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        ans = set()
        for i, a in enumerate(nums):
            if i and nums[i] == nums[i-1]:
                continue
            L = i+1
            R = len(nums)-1
            while L &lt; R:
                t = a + nums[L] + nums[R]
                if t &lt; 0:
                    L += 1
                elif t &gt; 0:
                    R -= 1
                else:
                    ans.add((a, nums[L], nums[R]))
                    L += 1
                    R -= 1
        return list(ans)
</code></pre></div></div>

<h3 id="16最接近的三数之和"><a href="https://leetcode-cn.com/problems/3sum-closest/description/">16.最接近的三数之和</a></h3>

<p>给定一个包括n个整数的数组nums和一个目标值target，找出nums中的三个整数，使得它们的和与target最接近，返回这三个数的和。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums.sort()
        ans = sum(nums[:3])
        dif = abs(target - ans)
        for i, a in enumerate(nums):
            if i and nums[i-1] == a:
                continue
            L = i+1
            R = len(nums)-1
            while L &lt; R:
                t = a + nums[L] + nums[R]
                if abs(t-target) &lt; dif:
                    dif = abs(t-target)
                    ans = t
                if t &lt; target:
                    L += 1
                elif t &gt; target:
                    R -= 1
                else:
                    break
        return ans
</code></pre></div></div>

<h3 id="17电话号码的字母组合"><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/">17.电话号码的字母组合</a></h3>

<p>在手机上数字2-9的键对应着字母a-z，给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if not digits:
            return []
        ans = ['']
        a = ['', '', 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']
        for d in digits:
            ans = [j+i for j in ans for i in a[int(d)]]
        return ans
</code></pre></div></div>

<h3 id="18四数之和"><a href="https://leetcode-cn.com/problems/4sum/description/">18.四数之和</a></h3>

<p>给定一个包含n个整数的数组nums和一个目标值target，判断nums中是否存在四个元素a,b,c,d使得a+b+c+d=target，找出所有满足条件且不重复的四元组。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums.sort()
        ans = set()
        for a, A in enumerate(nums):
            if a and nums[a-1] == A:
                continue
            for b in range(a+1, len(nums)):
                B = nums[b]
                if b-1 &gt; a and nums[b-1] == B:
                    continue
                L = b+1
                R = len(nums)-1
                while L &lt; R:
                    t = A+B+nums[L]+nums[R]
                    if t &lt; target:
                        L += 1
                    elif t &gt; target:
                        R -= 1
                    else:
                        ans.add((A,B,nums[L],nums[R]))
                        L += 1
                        R -= 1
        return list(ans)
</code></pre></div></div>

<h3 id="19删除链表的倒数第n个节点"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第N个节点</a></h3>

<p>给定一个链表，删除倒数第n个节点，并返回链表的头结点，给定的n保证有效。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        a, b, c = None, head, head
        for i in range(n):
            c = c.next
        while c:
            a, b, c = b, b.next, c.next
        if a:
            a.next = b.next
            return head
        return b.next
</code></pre></div></div>

<h3 id="20有效的括号"><a href="https://leetcode-cn.com/problems/valid-parentheses/description/">20.有效的括号</a></h3>

<p>给定一个只包含大中小括号的字符串，判断字符串是否有效。注意空字符串有效。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        a = []
        tag = {')':'(', ']':'[', '}':'{'}
        for i in s:
            if i in '([{':
                a.append(i)
            else:
                if a and a[-1] == tag[i]:
                    a.pop()
                else:
                    return False
        return len(a) == 0
</code></pre></div></div>]]></content><author><name>chenfy27</name></author><category term="LeetCode" /><summary type="html"><![CDATA[11.盛水最多的容器]]></summary></entry><entry><title type="html">leetcode 1-10</title><link href="https://chenfy27.github.io/2018/06/26/leetcode-1-10.html" rel="alternate" type="text/html" title="leetcode 1-10" /><published>2018-06-26T00:00:00+08:00</published><updated>2018-06-26T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/06/26/leetcode-1-10</id><content type="html" xml:base="https://chenfy27.github.io/2018/06/26/leetcode-1-10.html"><![CDATA[<p>为熟悉python，这里选择用它来写LeetCode上的题目练手，在能通过的前提下尽可能地让代码简单清晰。</p>

<h3 id="1两数之和"><a href="https://leetcode-cn.com/problems/two-sum/description/">1.两数之和</a></h3>

<p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数，输入保证有唯一解。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        ans = []
        a = {}
        for i in range(len(nums)):
            k = target - nums[i]
            if k in a:
                ans.extend([a[k], i])
                break
            a[nums[i]] = i
        return ans
</code></pre></div></div>

<h3 id="2两数相加"><a href="https://leetcode-cn.com/problems/add-two-numbers/description/">2.两数相加</a></h3>

<p>给定两个非空链表来表示两个非负整数，位数按照逆序方式存储，每个节点存一位数字，将两数相加并按该表式法返回结果。注意，数字没有前导0。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        c = 0
        ans = []
        while l1 or l2:
            if l1:
                c += l1.val
                l1 = l1.next
            if l2:
                c += l2.val
                l2 = l2.next
            ans.append(t % 10)
            c = c // 10
        if c: ans.append(c)
        node = None
        for i in ans[::-1]:
            t = ListNode(i)
            t.next = node
            node = t
        return node
</code></pre></div></div>

<h3 id="3无重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/">3.无重复字符的最长子串</a></h3>

<p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        d = {}
        i, j, k = 0, 0, 0
        while j &lt; len(s):
            d[s[j]] = 1 + d.get(s[j], 0)
            while d[s[j]] &gt; 1:
                d[s[i]] -= 1
                i += 1
            k = max(k, j-i+1)
            j += 1
        return k
</code></pre></div></div>

<h3 id="4两个排序数组的中位数"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/">4.两个排序数组的中位数</a></h3>

<p>给定两个大小分别为m和n的有序数组nums1与nums2，求这两个有序数组合并后的中位数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        nums = nums1 + nums2
        nums.sort()
        l = len(nums)
        return (nums[(l-1)//2] + nums[l//2]) / 2
</code></pre></div></div>

<h3 id="5最长回文子串"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/">5.最长回文子串</a></h3>

<p>给定一个字符串s，找到s中任意一个最长的回文子串。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        S = '##'
        for i in s:
            S += i + '#'
        M, R, ans = 0, 0, 0
        p = [0] * len(S)
        for i in range(len(S)):
            if i &lt; M:
                p[i] = max(p[2*M-i], R-i)
            else:
                p[i] = 1
            while i-p[i] &gt;= 0 and i+p[i] &lt; len(S) and S[i-p[i]] == S[i+p[i]]:
                p[i] += 1
            if R &lt; i+p[i]:
                M = i
                R = i+p[i]
            if ans &lt; p[i]-1:
                ans = p[i]-1
                z = i
        ret = ss[z-ans+1:z+ans].replace('#', '')
        return ret
</code></pre></div></div>

<h3 id="6z字形变换"><a href="https://leetcode-cn.com/problems/zigzag-conversion/description/">6.Z字形变换</a></h3>

<p>将字符串以Z字形排列成给定的行数，然后从左往右逐行读取字符得到新串，返回该新串。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def convert(self, s, numRows):
        """
        :type s: str
        :type numRows: int
        :rtype: str
        """
        if numRows &lt; 2: return s
        x, d = 0, 1
        t = [[] for i in range(numRows)]
        for i in s:
            t[x].append(i)
            x = x + d
            if x == numRows - 1:
                d = -1
            elif x == 0:
                d = 1
        ans = ''
        for i in t:
            ans += ''.join(i)
        return ans
</code></pre></div></div>

<h3 id="7反转整数"><a href="https://leetcode-cn.com/problems/reverse-integer/description/">7.反转整数</a></h3>

<p>给定一个32位有符号整数，将数字进行反转，如反转后会溢出，则返回0。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        s = str(x)
        sign = ''
        if s[0] == '-':
            sign = '-'
            s = s[1:]
        ans = sign + s[::-1]
        ans = int(ans)
        if ans &lt; -2**31 or ans &gt; 2**31-1:
            ans = 0
        return ans
</code></pre></div></div>

<h3 id="8字符串转整数"><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/description/">8.字符串转整数</a></h3>

<p>实现类似atoi的功能，将字符串转为整数。要求：</p>

<ul>
  <li>忽略起始的空白字符</li>
  <li>可以有前导的正负号</li>
  <li>可以在形成整数的字符后面有多余的字符，将被忽略</li>
  <li>对于无效字符串，返回0</li>
  <li>超出INT_MAX或INT_MIN，返回INT_MAX与INT_MIN</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def myAtoi(self, str):
        """
        :type str: str
        :rtype: int
        """
        s = str.lstrip()
        sign = 0
        ans = 0
        for i, j in enumerate(s):
            if i == 0:
                if j == '-':
                    sign = -1
                elif j == '+':
                    sign = 1
                elif j.isdigit():
                    sign = 1
                    ans = int(j)
                else:
                    return 0
            else:
                if j.isdigit():
                    ans = ans * 10 + int(j)
                else:
                    break
        ans *= sign
        ans = min(ans, 2**31-1)
        ans = max(ans, -2**31)
        return ans
</code></pre></div></div>

<h3 id="9回文数"><a href="https://leetcode-cn.com/problems/palindrome-number/description/">9.回文数</a></h3>

<p>判断一个整数是否是回文数，即正序读和倒序读是一样的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        s = str(x)
        return s == s[::-1]
</code></pre></div></div>

<h3 id="10正则表达式匹配"><a href="https://leetcode-cn.com/problems/regular-expression-matching/description/">10.正则表达式匹配</a></h3>

<p>给定一个字符串s和一个字符模式p，实现支持点号和星号的正则表达式匹配。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        p = '^' + p + '$'
        ok = re.match(p, s)
        return True if ok else False
</code></pre></div></div>]]></content><author><name>chenfy27</name></author><category term="LeetCode" /><summary type="html"><![CDATA[为熟悉python，这里选择用它来写LeetCode上的题目练手，在能通过的前提下尽可能地让代码简单清晰。]]></summary></entry><entry><title type="html">python中的栈和队列</title><link href="https://chenfy27.github.io/2018/06/23/queue-and-stack-in-python.html" rel="alternate" type="text/html" title="python中的栈和队列" /><published>2018-06-23T00:00:00+08:00</published><updated>2018-06-23T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/06/23/queue-and-stack-in-python</id><content type="html" xml:base="https://chenfy27.github.io/2018/06/23/queue-and-stack-in-python.html"><![CDATA[<p>栈和队列是较常用的数据结构，本文整理了它们在python下的高效实现方法。</p>

<h3 id="栈">栈</h3>

<p>python内置了list类型，通过它的append和pop方法就可以实现栈的功能，由于各项操作都是O(1)的，速度还算快。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Stack():
    def __init__(self):
        self.data = []
    
    def push(self, item):
        self.data.append(item)

    def top(self):
        return self.data[-1]

    def pop(self):
        self.data.pop()
    
    def empty(self):
        return len(self.data) == 0

    def size(self):
        return len(self.data)
</code></pre></div></div>

<p>经测试验证，使用collections模块中的deque来实现栈效率还要高些，deque常用的接口列出如下：</p>

<table border="1" cellspacing="0" style="width:800px; height:100px; text-align:left" cellpadding="6">
<tr><td>append(x)</td><td>add x to the right side of the deque</td></tr>
<tr><td>appendleft(x)</td><td>add x to the left side of the deque</td></tr>
<tr><td>pop()</td><td>remove and return an element from the right side of the deque</td></tr>
<tr><td>popleft()</td><td>remove and return an element from the left side of the deque</td></tr>
<tr><td>clear()</td><td>remove all elements from the deque</td></tr>
<tr><td>count(x)</td><td>count the number of elements equal to x</td></tr>
<tr><td>len(d)</td><td>return number of elements in deque d</td></tr>
<tr><td>if d:</td><td>check if deque d is empty or not</td></tr>
</table>
<p />

<p>在python中，对于list, tuple, string, dict等类型的对象x，都可以用if x的方式来判断是否为空。</p>

<p>对于栈，使用append和pop的组合即可实现。</p>

<h3 id="队列">队列</h3>

<p>可以用list的append/pop(0)或者insert(0)/pop()来实现队列，由于insert(0)和pop(0)是O(n)的，效率不够好，建议直接用标准库collections提供的deque。</p>

<p>对于队列，使用append和popleft的组合即可实现，当然也可以用appendleft和pop来做。</p>

<h3 id="优先队列">优先队列</h3>

<p>可以使用list结构自行实现二叉堆，而python库中也有多种实现，经过测试，性能最好的要属heapq模块，建议使用。</p>

<p>需要注意的是，python提供的二叉堆堆顶元素下标为0，并且默认均是小根堆。</p>

<table border="1" cellspacing="0" style="width:800px; height:100px; text-align:left" cellpadding="6">
<tr><td>heappush(heap, item)</td><td>push item onto heap and maintain heap invariant</td></tr>
<tr><td>heap[0]</td><td>access the smallest item without popping it</td></tr>
<tr><td>heappop(heap)</td><td>pop and return the smallest item from heap</td></tr>
<tr><td>heapify(x)</td><td>transform list x into a heap, in-place, in linear time</td></tr>
</table>
<p />

<h3 id="性能测试">性能测试</h3>

<p>下面编写代码对上述三种数据结构做性能测试。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import logging as log
from collections import deque
import heapq

def TestStack(n):
    log.debug('===== begin test stack =====')
    s = deque()
    for i in range(n):
        s.append(i)
    log.debug('stack push ok')
    i = n
    while s:
        i -= 1
        assert(i == s.pop())
    log.debug('stack pop ok')

def TestQueue(n):
    log.debug('===== begin test queue =====')
    q = deque()
    for i in range(n):
        q.append(i)
    log.debug('queue push ok')
    i = 0
    while q:
        assert(i == q.popleft())
        i += 1
    log.debug('queue pop ok')

def TestPriorityQueue(n):
    log.debug('===== begin test priority queue =====')
    pq = []
    for i in range(n):
        heapq.heappush(pq, i)
    log.debug('priority queue push ok')
    i = 0
    while pq:
        assert(i == pq[0])
        heapq.heappop(pq)
        i += 1
    log.debug('priority queue pop ok')

def main():
    log.basicConfig(level=log.DEBUG, format='%(asctime)s - %(message)s')
    N = 1000000
    TestStack(N)
    TestQueue(N)
    TestPriorityQueue(N)

if __name__ == '__main__':
    main()
</code></pre></div></div>

<p>某次运行结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ time python3 z.py 
2018-06-23 15:34:45,030 - ===== begin test stack =====
2018-06-23 15:34:45,175 - stack push ok
2018-06-23 15:34:45,384 - stack pop ok
2018-06-23 15:34:45,384 - ===== begin test queue =====
2018-06-23 15:34:45,521 - queue push ok
2018-06-23 15:34:45,740 - queue pop ok
2018-06-23 15:34:45,740 - ===== begin test priority queue =====
2018-06-23 15:34:46,001 - priority queue push ok
2018-06-23 15:34:46,859 - priority queue pop ok

real       0m1.889s
user       0m1.790s
sys        0m0.078s
</code></pre></div></div>

<p>运行速度非常快，接近C/C++的性能。</p>]]></content><author><name>chenfy27</name></author><category term="python" /><summary type="html"><![CDATA[栈和队列是较常用的数据结构，本文整理了它们在python下的高效实现方法。]]></summary></entry><entry><title type="html">stl常用容器方法</title><link href="https://chenfy27.github.io/2018/06/22/common-stl-containers.html" rel="alternate" type="text/html" title="stl常用容器方法" /><published>2018-06-22T00:00:00+08:00</published><updated>2018-06-22T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/06/22/common-stl-containers</id><content type="html" xml:base="https://chenfy27.github.io/2018/06/22/common-stl-containers.html"><![CDATA[<h3 id="vector">vector</h3>

<ul>
  <li>push_back(val)</li>
  <li>pop_back()</li>
  <li>empty()</li>
  <li>size()</li>
  <li>front()</li>
  <li>back()</li>
  <li>insert(pos, val)</li>
  <li>erase(pos)</li>
  <li>clear()</li>
</ul>

<h3 id="stack">stack</h3>

<ul>
  <li>push(val)</li>
  <li>top()</li>
  <li>pop()</li>
  <li>empty()</li>
  <li>size()</li>
</ul>

<h3 id="queue">queue</h3>

<ul>
  <li>push(val)</li>
  <li>front()</li>
  <li>pop()</li>
  <li>empty()</li>
  <li>size()</li>
</ul>

<h3 id="deque">deque</h3>

<ul>
  <li>push_back(val)</li>
  <li>push_front(val)</li>
  <li>front()</li>
  <li>back()</li>
  <li>pop_back()</li>
  <li>pop_front()</li>
  <li>empty()</li>
  <li>size()</li>
</ul>

<h3 id="priority_queue">priority_queue</h3>

<ul>
  <li>push(val)</li>
  <li>top()</li>
  <li>pop()</li>
  <li>empty()</li>
  <li>size()</li>
</ul>

<h3 id="list">list</h3>

<ul>
  <li>push_back(val)</li>
  <li>push_front(val)</li>
  <li>front()</li>
  <li>back()</li>
  <li>pop_back()</li>
  <li>pop_front()</li>
  <li>insert(pos, val)</li>
  <li>erase(pos)</li>
  <li>clear()</li>
  <li>sort()</li>
  <li>unique()</li>
  <li>reverse()</li>
  <li>remove()</li>
  <li>remove_if()</li>
  <li>merge()</li>
</ul>

<h3 id="mapmultimapunordered_map">map/multimap/unordered_map</h3>

<ul>
  <li>insert(make_pair(key, val))</li>
  <li>mp[key] = val (for map and unordered_map)</li>
  <li>erase(key)</li>
  <li>empty()</li>
  <li>size()</li>
  <li>clear()</li>
  <li>find(key)</li>
  <li>count(key)</li>
  <li>lower_bound(key) (for map and multimap)</li>
  <li>upper_bound(key) (for map and multimap)</li>
  <li>equal_range(key)</li>
</ul>

<h3 id="setmultisetunordered_set">set/multiset/unordered_set</h3>

<ul>
  <li>insert(key)</li>
  <li>erase(key)</li>
  <li>empty()</li>
  <li>size()</li>
  <li>clear()</li>
  <li>find(key)</li>
  <li>count(key)</li>
  <li>lower_bound(key) (for set and multiset)</li>
  <li>upper_bound(key) (for set and multiset)</li>
  <li>equal_range(key)</li>
</ul>]]></content><author><name>chenfy27</name></author><category term="cpp" /><summary type="html"><![CDATA[vector]]></summary></entry><entry><title type="html">线性回归之最小二乘法</title><link href="https://chenfy27.github.io/2018/06/21/linear-regression-by-least-squares.html" rel="alternate" type="text/html" title="线性回归之最小二乘法" /><published>2018-06-21T00:00:00+08:00</published><updated>2018-06-21T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/06/21/linear-regression-by-least-squares</id><content type="html" xml:base="https://chenfy27.github.io/2018/06/21/linear-regression-by-least-squares.html"><![CDATA[<h3 id="问题描述">问题描述</h3>

<p>假设自变量\((X_{1}, X_{2},\cdots,X_{n})\)与因变量\(Y\)之间满足某种线性关系：</p>

\[Y = \theta_{0} + \theta_{1}X_{1} + \theta_{2}X_{2} + \cdots + \theta_{n}X_{n}\]

<p>为了表示方便，令\(X_{0}=1\)，那么上式可用矩阵的方式简写为：</p>

\[Y = X^{T}\theta\]

<p>其中\(X\)和\(\theta\)为列向量。</p>

\[X = 
\begin{bmatrix}
    X_{0} \\
    X_{1} \\
    \cdots \\
    X_{n} \\
\end{bmatrix}
,
\theta =
\begin{bmatrix}
    \theta_{0} \\
    \theta_{1} \\
    \cdots \\
    \theta_{n} \\
\end{bmatrix}\]

<p>现给出\(m\)组样本数据，求参数\(\theta\)，使上述等式关系尽可能得符合各个样本。这是一个典型的线性回归问题，常见的解法是最小二乘法和梯度下降法，这里介绍最小二乘法。</p>

<h3 id="最小二乘法">最小二乘法</h3>

<p>根据关系式\(Y = X^{T}\theta\)，构造残差函数\(L(\theta)=\frac{1}{2}(X^{T}\theta-Y)^{T}(X^{T}\theta-Y)\)，为了让\(L(\theta)\)取得最小值，令\(L(\theta)\)对\(\theta\)的一阶导数为零，解出\(\theta\)：</p>

\[\theta = (X^{T}X)^{-1} X^{T} Y\]

<p>可见，通过最小二乘法求解\(\theta\)主要是进行矩阵乘法运算，由于矩阵乘法的时间复杂度是\(O(n^{3})\)级别的，因此只适用于数据量较小的场景。</p>

<h3 id="求解实例">求解实例</h3>

<p>假设有线性关系\(Y = 9 + 4X_{1} + X_{2} + 2X_{3}\)，下面随机生成一些数据作为样本，用于求解系数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import random

def func(x1, x2, x3):
    return 9 + 4*x1 + x2 + 2*x3

for i in range(5):
    x1 = random.randint(1, 10)
    x2 = random.randint(1, 10)
    x3 = random.randint(1, 10)
    y = func(x1, x2, x3)
    print(y, x1, x2, x3)
</code></pre></div></div>

<p>某次运行结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>71 10 8 7
72 10 5 9
42 2 5 10
39 1 8 9
56 6 7 8
</code></pre></div></div>

<p>下面根据最小二乘法的结论来求解参数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import numpy as np
from numpy import dot
from numpy.linalg import inv

X = np.array([[1,10,8,7],[1,10,5,9],[1,2,5,10],[1,1,8,9],[1,6,7,8]])
Y = np.array([[71],[72],[42],[39],[56]])

theta = dot(dot(inv(dot(X.T, X)), X.T), Y)
print(theta)
</code></pre></div></div>

<p>运行结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[9.]
[4.]
[1.]
[2.]]
</code></pre></div></div>

<p>即通过回归分析得到的关系式为：\(Y = 9 + 4X_{1} + X_{2} + 2X_{3}\)，与预期相符。</p>

<p>再如，假定国内生产总值GDP与消费Consumption、货币供应量MO、进出口总额EM以及投资Investment这4个因素存在某种线性关系，<a href="/data/yeardata.csv">这里</a>提供了一些样本数据，试着量化该线性关系。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import pandas as pd
import numpy as np
from numpy import dot
from numpy.linalg import inv

data = pd.read_csv('yeardata.csv')
X = data.iloc[:, 1:5]
X['X0'] = 1
X = X.iloc[:, [4,0,1,2,3]]
#print(X)
Y = data.iloc[:, 0]
#print(Y)

theta = dot(dot(inv(dot(X.T, X)), X.T), Y)
print(theta)
</code></pre></div></div>

<p>计算结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-94.51398652   1.32825128   2.06138007   0.38959829   0.11848647]
</code></pre></div></div>

<p>即\(GDP = -94.514 + 1.328Consumption + 2.061MO + 0.390EM + 0.118Investment\)。</p>]]></content><author><name>chenfy27</name></author><category term="机器" /><summary type="html"><![CDATA[问题描述]]></summary></entry><entry><title type="html">支持多语言gettext</title><link href="https://chenfy27.github.io/2018/06/18/gettext.html" rel="alternate" type="text/html" title="支持多语言gettext" /><published>2018-06-18T00:00:00+08:00</published><updated>2018-06-18T00:00:00+08:00</updated><id>https://chenfy27.github.io/2018/06/18/gettext</id><content type="html" xml:base="https://chenfy27.github.io/2018/06/18/gettext.html"><![CDATA[<p>有时，程序展现给用户的信息需要支持多种语言，并且允许在语言之间做灵活的切换，最为常见的场景是支持中英文，GNU的gettext是一个支持多语言的成熟解决方案。</p>

<h3 id="编程接口">编程接口</h3>

<p>使用gettext需要用到的API如下所示：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;locale.h&gt;
#include &lt;libintl.h&gt;

char* setlocale(int category, const char *locale);
char* bindtextdomain(const char *domainname, const char *dirname);
char* textdomain(const char *domainname);
</code></pre></div></div>

<p>其中：</p>

<ul>
  <li>mo文件位置一般是dirname/locale/category/domainname.mo。</li>
  <li>bindtextdomain与textdomain中的domainname参数必须一致，为mo文件的文件名，不带.mo后缀。</li>
</ul>

<h3 id="使用示例">使用示例</h3>

<p>以输出hello为例，以下是相关源码hello.c，假设mo文件取名为scott.mo。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;locale.h&gt;
#include &lt;libintl.h&gt;

#define _(str) gettext(str)

int main(int argc, char *argv[]) {
    setlocale(LC_ALL, "");
    bindtextdomain("scott", "lang");
    textdomain("scott");
    puts(_("hello"));
    return 0;
}
</code></pre></div></div>

<p>编译时需要链上intl库。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -o hello hello.c -g -Wall -lintl
</code></pre></div></div>

<p>通过xgettext工具从代码中自动提取需要翻译的内容，得到scott.po文件。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ xgettext -k_ hello.c -o scott.po

$ cat  scott.po
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-06-19 10:17+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n"
"Language-Team: LANGUAGE &lt;LL@li.org&gt;\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#: hello.c:11
msgid "hello"
msgstr ""

$ mkdir -p lang/{en_US,zh_CN}/LC_MESSAGES
$ cp scott.po lang/en_US/LC_MESSAGES
$ cp scott.po lang/zh_CN/LC_MESSAGES
</code></pre></div></div>

<p>修改各po文件的msgstr项，设成翻译后的内容。作为例子，这里生成了zh_CN和en_US两个po文件，其中zh_CN的scott.po里msgstr置成”say hello in chinese”, 而en_US的scott.po设为”say hello in english”。另外，默认生成的po文件charset未设置，建议改成UTF-8。</p>

<p>接着根据po文本文件成mo二进制文件。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ msgfmt scott.po -o scott.mo
</code></pre></div></div>

<p>最后，运行程序，将根据当前语言输出对应的内容。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo $LANG
zh_CN.UTF-8
$ ./hello 
say hello in chinese
$ export LANG=en_US
$ ./hello 
say hello in english
</code></pre></div></div>]]></content><author><name>chenfy27</name></author><category term="平台" /><summary type="html"><![CDATA[有时，程序展现给用户的信息需要支持多种语言，并且允许在语言之间做灵活的切换，最为常见的场景是支持中英文，GNU的gettext是一个支持多语言的成熟解决方案。]]></summary></entry></feed>